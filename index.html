<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipél Chat</title>
    <style>
        @font-face {
            font-family: 'CustomMono';
            src: url('font.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            background-color: #000;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            margin: 0;
            padding: 10px;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 14px;
        }
        #terminal {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            margin-top: 5px;
        }
        #help-btn {
            color: #0f0;
            cursor: pointer;
            margin-right: 5px;
            white-space: nowrap;
            font-size: 14px;
            text-decoration: underline;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #help-btn:hover {
            color: #0ff;
        }
        #prompt {
            white-space: nowrap;
            margin-right: 5px;
            font-size: 14px;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #command-input {
            background-color: transparent;
            border: none;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            font-size: 14px;
            width: 100%;
            outline: none;
        }
        .output {
            white-space: pre-wrap;
            margin: 5px 0;
            color: #0f0; /* Зеленый для вывода */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .command {
            margin: 5px 0;
            color: #fff;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .chat-message {
            margin: 2px 0;
            color: #ff0; /* Желтый для чат-сообщений */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .user-chat-message {
            margin: 2px 0;
            color: #0ff; /* Голубой для сообщений пользователя */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .notification {
            margin: 2px 0;
            color: #f0f; /* Фиолетовый для уведомлений */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .pinned {
            background-color: #111;
            border: 1px solid #333;
            padding: 5px;
            margin: 10px 0;
            font-weight: bold;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .bot-ban {
            margin: 2px 0;
            color: #f00; /* Красный для бана бота */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .online {
            color: #0f0;
        }
        .offline {
            color: #888;
        }
        @media (max-width: 600px) {
            body {
                padding: 5px;
                font-size: 12px;
            }
            #help-btn, #prompt, #command-input {
                font-size: 12px;
            }
            #terminal {
                padding-right: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="terminal">
    </div>
    <div id="input-line">
        <span id="help-btn">[help]</span>
        <span id="prompt">user@localhost:~$</span>
        <input type="text" id="command-input" autofocus>
    </div>

    <!-- Firebase JS SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>

    <script>
        // Firebase config
        const firebaseConfig = {
          apiKey: "AIzaSyDBBm7_VBqW0smF-7ecP1vaeTnMY68lc_w",
          authDomain: "my-terminal-chat-ecd4e.firebaseapp.com",
          projectId: "my-terminal-chat-ecd4e",
          storageBucket: "my-terminal-chat-ecd4e.firebasestorage.app",
          messagingSenderId: "401735371021",
          appId: "1:401735371021:web:81b1cf519130febee78844",
          measurementId: "G-SJ6VNQDS9M"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('command-input');
        const prompt = document.getElementById('prompt');
        const helpBtn = document.getElementById('help-btn');
        
        // Language support
        let currentLang = 'en';
        const translations = {
            en: {
                helpHint: "Type 'help' for available commands",
                help: `Available commands:
- help: Show this help message
- clear: Clear the terminal
- date: Show current date and time
- nick [name]: Set your nickname (only once) - registers you
- obchat: Enter general chat (type /exit to leave)
- tongue [lang]: Change language (en, ru, zh)
- notif: Show notifications`,
                adminHelp: `\nAdmin commands (nk.exe2089 only):
- ban [nick] [time] [reason]: Ban a user from entering chat
- unban [nick] [reason]: Unban a user from chat
- bot [on|off]: Toggle moderation bot in chat
- prov: Check bot status`,
                dateCmd: () => new Date().toString(),
                nickSet: (nick) => `Nickname set to ${nick}. You are now registered!`,
                nickAlreadySet: 'Nickname can only be set once.',
                nickUsage: 'Usage: nick <name>',
                setNickFirst: 'Please set a nickname first using "nick <name>".',
                obchatEnter: 'Entered general chat. Type messages to chat. Use /exit to leave.',
                obchatLeave: 'Left general chat.',
                chatFull: 'Chat is full. Maximum 100 users.',
                unknownChatCmd: (cmd) => `Unknown chat command: /${cmd}`,
                unknownLang: (lang) => `Unknown language: ${lang}. Available: en, ru, zh`,
                tongueUsage: 'Usage: tongue <lang> (en, ru, zh)',
                onlyAdmin: 'This command is only available to the admin.',
                banUsage: 'Usage: ban <nick> <time> [reason]\nTime format: 30s, 50m, 78h, 79d (or 30с, 50м, 78ч, 79д)',
                banSet: (nick, end, reason) => `User ${nick} has been banned until ${end} for: ${reason}`,
                youBanned: (end, reason) => `You are banned from entering chat until ${end} for: ${reason}`,
                unbanUsage: 'Usage: unban <nick> [reason]',
                unbanDone: (nick, reason) => `User ${nick} has been unbanned. Reason: ${reason}`,
                notBanned: (nick) => `User ${nick} is not banned.`,
                botOn: 'Moderation bot enabled in chat.',
                botOff: 'Moderation bot disabled in chat.',
                botStatusOn: 'Bot is ON.',
                botStatusOff: 'Bot is OFF.',
                botInvalid: 'Usage: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} banned for 5 minutes for insults to relatives.`,
                notifTitle: 'Notifications:\n',
                notifEmpty: 'No notifications.'
            },
            ru: {
                helpHint: "Введите 'help' для списка команд",
                help: `Доступные команды:
- help: Показать это сообщение помощи
- clear: Очистить терминал
- date: Показать текущую дату и время
- nick [имя]: Установить ваш никнейм (только один раз) - регистрирует вас
- obchat: Войти в общий чат (введите /exit для выхода)
- tongue [lang]: Сменить язык (en, ru, zh)
- notif: Показать уведомления`,
                adminHelp: `\nКоманды администратора (только для nk.exe2089):
- ban [ник] [время] [причина]: Забанить пользователя от входа в чат
- unban [ник] [причина]: Разбанить пользователя из чата
- bot [on|off]: Включить/выключить модерационного бота в чате
- prov: Проверить статус бота`,
                dateCmd: () => new Date().toLocaleString('ru-RU'),
                nickSet: (nick) => `Никнейм установлен: ${nick}. Вы теперь зарегистрированы!`,
                nickAlreadySet: 'Никнейм можно установить только один раз.',
                nickUsage: 'Использование: nick <имя>',
                setNickFirst: 'Сначала установите никнейм с помощью "nick <имя>".',
                obchatEnter: 'Вошли в общий чат. Пишите сообщения для общения. Используйте /exit для выхода.',
                obchatLeave: 'Вышли из общего чата.',
                chatFull: 'Чат заполнен. Максимум 100 пользователей.',
                unknownChatCmd: (cmd) => `Неизвестная команда чата: /${cmd}`,
                unknownLang: (lang) => `Неизвестный язык: ${lang}. Доступны: en, ru, zh`,
                tongueUsage: 'Использование: tongue <lang> (en, ru, zh)',
                onlyAdmin: 'Эта команда доступна только администратору.',
                banUsage: 'Использование: ban <ник> <время> [причина]\nФормат времени: 30s, 50m, 78h, 79d (или 30с, 50м, 78ч, 79д)',
                banSet: (nick, end, reason) => `Пользователь ${nick} забанен до ${end} за: ${reason}`,
                youBanned: (end, reason) => `Вы забанены от входа в чат до ${end} за: ${reason}`,
                unbanUsage: 'Использование: unban <ник> [причина разбана]',
                unbanDone: (nick, reason) => `Пользователь ${nick} разбанен. Причина: ${reason}`,
                notBanned: (nick) => `Пользователь ${nick} не забанен.`,
                botOn: 'Модерационный бот включен в чате.',
                botOff: 'Модерационный бот выключен в чате.',
                botStatusOn: 'Бот включен.',
                botStatusOff: 'Бот выключен.',
                botInvalid: 'Использование: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} забанен на 5 минут за оскорбления родных.`,
                notifTitle: 'Уведомления:\n',
                notifEmpty: 'Нет уведомлений.'
            },
            zh: {
                helpHint: "输入 'help' 查看可用命令",
                help: `可用命令:
- help: 显示此帮助消息
- clear: 清空终端
- date: 显示当前日期和时间
- nick [name]: 设置您的昵称 (仅一次) - 注册您
- obchat: 进入通用聊天 (输入 /exit 退出)
- tongue [lang]: 更改语言 (en, ru, zh)
- notif: 显示通知`,
                adminHelp: `\n管理员命令 (仅 nk.exe2089):
- ban [nick] [time] [reason]: 禁止用户进入聊天
- unban [nick] [reason]: 解除用户聊天禁令
- bot [on|off]: 切换聊天中的 moderation bot
- prov: 检查 bot 状态`,
                dateCmd: () => new Date().toLocaleString('zh-CN'),
                nickSet: (nick) => `昵称设置为 ${nick}。您现在已注册！`,
                nickAlreadySet: '昵称只能设置一次。',
                nickUsage: '用法: nick <name>',
                setNickFirst: '请先使用 "nick <name>" 设置昵称。',
                obchatEnter: '已进入通用聊天。输入消息聊天。使用 /exit 退出。',
                obchatLeave: '已离开通用聊天。',
                chatFull: '聊天已满。最多 100 用户。',
                unknownChatCmd: (cmd) => `未知聊天命令: /${cmd}`,
                unknownLang: (lang) => `未知语言: ${lang}。可用: en, ru, zh`,
                tongueUsage: '用法: tongue <lang> (en, ru, zh)',
                onlyAdmin: '此命令仅管理员可用。',
                banUsage: '用法: ban <nick> <time> [reason]\n时间格式: 30s, 50m, 78h, 79d (或 30с, 50м, 78ч, 79д)',
                banSet: (nick, end, reason) => `用户 ${nick} 被禁止直到 ${end} 原因: ${reason}`,
                youBanned: (end, reason) => `您被禁止进入聊天直到 ${end} 原因: ${reason}`,
                unbanUsage: '用法: unban <nick> [reason]',
                unbanDone: (nick, reason) => `用户 ${nick} 已解除禁令。原因: ${reason}`,
                notBanned: (nick) => `用户 ${nick} 未被禁止。`,
                botOn: '聊天 moderation bot 已启用。',
                botOff: '聊天 moderation bot 已禁用。',
                botStatusOn: 'Bot 已开启。',
                botStatusOff: 'Bot 已关闭。',
                botInvalid: '用法: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} 被禁 5 分钟因 insults to relatives。`,
                notifTitle: '通知:\n',
                notifEmpty: '无通知。'
            }
        };
        
        function updateLanguage() {
            const t = translations[currentLang];
            const helpHintEl = document.getElementById('help-hint');
            if (helpHintEl) helpHintEl.textContent = t.helpHint;
        }
        
        // Chat simulation
        let currentNick = 'user';
        let isNickSet = false;
        let inChat = false;
        let bannedUsers = new Map();
        let botEnabled = false;
        let notifications = [];
        let registeredUsers = new Map(); // lowerNick -> {displayNick, ip, regTime}
        let chatListener = null;
        let onlineUsers = new Set();
        let onlineRef = null;
        let onlineListener = null;
        
        // Firebase paths
        const USERS_PATH = 'users';
        const BANS_PATH = 'bans';
        const CHAT_MESSAGES_PATH = 'chat_messages';
        const BOT_SETTINGS_PATH = 'bot_settings';
        const ONLINE_USERS_PATH = 'online_users';
        
        // Load state from Firebase
        async function loadState() {
            try {
                // Load user data using the persisted nick
                const lowerNick = currentNick.toLowerCase();
                const userSnapshot = await db.ref(`${USERS_PATH}/${lowerNick}`).once('value');
                const userData = userSnapshot.val();
                if (userData) {
                    currentLang = userData.lang || 'en';
                    isNickSet = userData.is_nick_set || false;
                    notifications = userData.notifications || [];
                    notifications = notifications.slice(-50);
                }

                // Load bot enabled
                const botSnapshot = await db.ref(BOT_SETTINGS_PATH).once('value');
                const botData = botSnapshot.val();
                botEnabled = botData?.enabled || false;

                // Load bans
                await loadBans();

                // Load registered users
                const regsSnapshot = await db.ref(USERS_PATH).once('value');
                if (regsSnapshot.exists()) {
                    regsSnapshot.forEach((childSnapshot) => {
                        const user = childSnapshot.val();
                        const key = childSnapshot.key;
                        registeredUsers.set(key, {
                            displayNick: user.display_nick,
                            ip: user.ip,
                            regTime: new Date(user.reg_time).getTime()
                        });
                    });
                }

                updateLanguage();
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        // Save user state
        async function saveUserState() {
            try {
                const lowerNick = currentNick.toLowerCase();
                await db.ref(`${USERS_PATH}/${lowerNick}`).set({
                    display_nick: currentNick,
                    lang: currentLang,
                    is_nick_set: isNickSet,
                    notifications: notifications,
                    ip: generateIP(),
                    reg_time: new Date().toISOString()
                });
            } catch (error) {
                console.error('Error saving user state:', error);
            }
        }

        // Load bans
        async function loadBans() {
            try {
                const bansSnapshot = await db.ref(BANS_PATH).once('value');
                bannedUsers.clear();
                const toRemove = [];
                if (bansSnapshot.exists()) {
                    bansSnapshot.forEach((childSnapshot) => {
                        const ban = childSnapshot.val();
                        const endTime = new Date(ban.end_time).getTime();
                        if (Date.now() < endTime) {
                            bannedUsers.set(childSnapshot.key, {
                                endTime,
                                reason: ban.reason
                            });
                        } else {
                            toRemove.push(childSnapshot.key);
                        }
                    });
                }
                if (toRemove.length > 0) {
                    await Promise.all(toRemove.map(key => db.ref(`${BANS_PATH}/${key}`).remove()));
                }
            } catch (error) {
                console.error('Error loading bans:', error);
            }
        }

        // Save bans
        async function saveBans() {
            try {
                const updates = {};
                bannedUsers.forEach((ban, nick) => {
                    updates[`${BANS_PATH}/${nick}`] = {
                        end_time: new Date(ban.endTime).toISOString(),
                        reason: ban.reason
                    };
                });
                await db.ref().update(updates);
            } catch (error) {
                console.error('Error saving bans:', error);
            }
        }

        // Save bot state
        async function saveBotState(enabled) {
            try {
                await db.ref(BOT_SETTINGS_PATH).set({ enabled });
                botEnabled = enabled;
            } catch (error) {
                console.error('Error saving bot state:', error);
            }
        }

        function addNotification(msg) {
            const timestamp = new Date().toLocaleString(getLocale());
            const notif = `${timestamp}: ${msg}`;
            notifications.push(notif);
            notifications = notifications.slice(-50);
            saveUserState();
        }

        async function registerUser(nick) {
            await saveUserState(); // Registers via set
        }

        async function saveBan(nick, banData) {
            const lowerNick = nick.toLowerCase();
            bannedUsers.set(lowerNick, banData);
            await db.ref(`${BANS_PATH}/${lowerNick}`).set({
                end_time: new Date(banData.endTime).toISOString(),
                reason: banData.reason
            });
        }

        async function deleteBan(nick) {
            const lowerNick = nick.toLowerCase();
            bannedUsers.delete(lowerNick);
            await db.ref(`${BANS_PATH}/${lowerNick}`).remove();
        }

        // Load chat messages realtime
        function loadChatMessages() {
            if (chatListener) {
                db.ref(CHAT_MESSAGES_PATH).off('child_added', chatListener);
            }
            const chatRef = db.ref(CHAT_MESSAGES_PATH);
            chatListener = (snapshot) => {
                const msg = snapshot.val();
                const msgElement = document.createElement('div');
                msgElement.className = 'chat-message output';
                msgElement.textContent = `${msg.nick}: ${msg.text}`;
                terminal.appendChild(msgElement);
                terminal.scrollTop = terminal.scrollHeight;
            };
            chatRef.on('child_added', chatListener);
        }

        function unloadChatMessages() {
            if (chatListener) {
                db.ref(CHAT_MESSAGES_PATH).off('child_added', chatListener);
                chatListener = null;
            }
        }

        // Online status
        async function setOnline() {
            const lowerNick = currentNick.toLowerCase();
            await db.ref(`${ONLINE_USERS_PATH}/${lowerNick}`).set(firebase.database.ServerValue.TIMESTAMP);
        }

        async function setOffline() {
            const lowerNick = currentNick.toLowerCase();
            await db.ref(`${ONLINE_USERS_PATH}/${lowerNick}`).remove();
        }

        // Listen for online users
        function setupOnlineListener() {
            onlineRef = db.ref(ONLINE_USERS_PATH);
            onlineListener = (snapshot) => {
                const data = snapshot.val() || {};
                onlineUsers.clear();
                Object.entries(data).forEach(([key, val]) => {
                    const lastSeen = val;
                    if (Date.now() - lastSeen < 30000) {
                        onlineUsers.add(key);
                    }
                });
            };
            onlineRef.on('value', onlineListener);
        }

        async function loadOnlineUsers() {
            const { data } = await db.ref(ONLINE_USERS_PATH).once('value');
            // Not needed, listener handles
        }

        function getTranslations() {
            return translations[currentLang];
        }
        
        function getLocale() {
            switch (currentLang) {
                case 'en': return 'en-US';
                case 'ru': return 'ru-RU';
                case 'zh': return 'zh-CN';
                default: return 'en-US';
            }
        }
        
        function generateIP() {
            return `192.168.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
        }
        
        function parseDuration(str) {
            const match = str.match(/^(\d+)([smhdсмчд])$/i);
            if (!match) return null;
            const num = parseInt(match[1]);
            let unit = match[2].toLowerCase();
            switch (unit) {
                case 's':
                case 'с': return num * 1000;
                case 'm':
                case 'м': return num * 60 * 1000;
                case 'h':
                case 'ч': return num * 60 * 60 * 1000;
                case 'd':
                case 'д': return num * 24 * 60 * 60 * 1000;
                default: return null;
            }
        }
        
        function isAdmin() {
            return currentNick === 'nk.exe2089';
        }
        
        function handleBotModeration(message, senderNick) {
            // Test mode - no action for now
            console.log('Bot test: message checked');
        }
        
        async function checkBanAndExitIfNeeded() {
            const lowerNick = currentNick.toLowerCase();
            if (bannedUsers.has(lowerNick)) {
                const ban = bannedUsers.get(lowerNick);
                if (Date.now() < ban.endTime) {
                    inChat = false;
                    updatePrompt();
                    unloadChatMessages();
                    await setOffline();
                    const t = getTranslations();
                    const locale = getLocale();
                    const endStr = new Date(ban.endTime).toLocaleString(locale);
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = t.youBanned(endStr, ban.reason);
                    terminal.appendChild(outputElement);
                    saveTerminal();
                    terminal.scrollTop = terminal.scrollHeight;
                    return true; // Kicked
                } else {
                    await deleteBan(lowerNick);
                }
            }
            return false; // Not kicked
        }
        
        // Function to execute help command
        async function executeHelp() {
            if (inChat) {
                // If in chat, just output help as message or exit first? For simplicity, output in terminal
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} help`;
                terminal.appendChild(inputElement);
                
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = helpText;
                terminal.appendChild(outputElement);
            } else {
                // Normal mode
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} help`;
                terminal.appendChild(inputElement);
                
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = helpText;
                terminal.appendChild(outputElement);
            }
            saveTerminal();
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        // Local commands
        function updatePrompt() {
            const t = getTranslations();
            if (inChat) {
                prompt.textContent = `${currentNick}@obchat: `;
            } else {
                prompt.textContent = `${currentNick}@localhost:~$`;
            }
        }
        
        const localCommands = {
            'help': () => {
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                return helpText;
            },
            'clear': (args) => {
                // Clear outputs but keep pinned
                const pinned = terminal.querySelectorAll('.pinned');
                terminal.innerHTML = '';
                pinned.forEach(p => terminal.appendChild(p));
                inChat = false;
                updatePrompt();
                updateLanguage();
                saveTerminal();
                return '';
            },
            'date': () => {
                const t = getTranslations();
                return t.dateCmd();
            },
            'nick': async (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    if (isNickSet) {
                        return t.nickAlreadySet;
                    }
                    const oldNick = currentNick;
                    currentNick = args.join(' ');
                    localStorage.setItem('currentNick', currentNick); // Persist nick in localStorage
                    isNickSet = true;
                    await registerUser(currentNick);
                    updatePrompt();
                    // If was admin, check if new is admin too
                    if (oldNick === 'nk.exe2089' && currentNick !== 'nk.exe2089') {
                        return `Nickname changed from ${oldNick} to ${currentNick}. Admin privileges lost.`;
                    }
                    await saveUserState();
                    return t.nickSet(currentNick);
                } else {
                    return t.nickUsage;
                }
            },
            'obchat': async () => {
                await loadBans(); // Ensure bans are loaded
                const t = getTranslations();
                if (!isNickSet) {
                    return t.setNickFirst;
                }
                if (onlineUsers.size >= 100) {
                    return t.chatFull;
                }
                const lowerNick = currentNick.toLowerCase();
                if (bannedUsers.has(lowerNick)) {
                    const ban = bannedUsers.get(lowerNick);
                    if (Date.now() < ban.endTime) {
                        const locale = getLocale();
                        const endStr = new Date(ban.endTime).toLocaleString(locale);
                        return t.youBanned(endStr, ban.reason);
                    } else {
                        await deleteBan(lowerNick);
                    }
                }
                inChat = true;
                updatePrompt();
                loadChatMessages();
                await setOnline();
                return t.obchatEnter;
            },
            'tongue': async (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    const lang = args[0].toLowerCase();
                    if (['en', 'ru', 'zh'].includes(lang)) {
                        currentLang = lang;
                        await saveUserState();
                        updateLanguage();
                        updatePrompt();
                        return `Language changed to ${lang}`;
                    } else {
                        return t.unknownLang(lang);
                    }
                } else {
                    return t.tongueUsage;
                }
            },
            'notif': () => {
                const t = getTranslations();
                if (notifications.length === 0) {
                    return t.notifEmpty;
                }
                let output = t.notifTitle;
                notifications.forEach(n => {
                    output += `${n}\n`;
                });
                return output;
            },
            'ban': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 2) {
                    return t.banUsage;
                }
                const nick = args[0];
                const timeStr = args[1];
                const reason = args.slice(2).join(' ') || 'No reason provided';
                const duration = parseDuration(timeStr);
                if (!duration) {
                    return t.banUsage;
                }
                const endTime = Date.now() + duration;
                const locale = getLocale();
                const endStr = new Date(endTime).toLocaleString(locale);
                const banData = { endTime, reason };
                await saveBan(nick, banData);
                const banMsg = t.banSet(nick, endStr, reason);
                addNotification(banMsg);
                // Check if self-banned and in chat
                if (nick.toLowerCase() === currentNick.toLowerCase() && inChat) {
                    checkBanAndExitIfNeeded();
                }
                return banMsg;
            },
            'unban': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 1) {
                    return t.unbanUsage;
                }
                const nick = args[0];
                const reason = args.slice(1).join(' ') || 'No reason provided';
                const lowerNick = nick.toLowerCase();
                if (!bannedUsers.has(lowerNick)) {
                    return t.notBanned(nick);
                }
                await deleteBan(lowerNick);
                const unbanMsg = t.unbanDone(nick, reason);
                addNotification(unbanMsg);
                return unbanMsg;
            },
            'bot': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 1) {
                    return t.botInvalid;
                }
                const action = args[0].toLowerCase();
                if (action === 'on') {
                    await saveBotState(true);
                    return t.botOn;
                } else if (action === 'off') {
                    await saveBotState(false);
                    return t.botOff;
                } else {
                    return t.botInvalid;
                }
            },
            'prov': () => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                return botEnabled ? t.botStatusOn : t.botStatusOff;
            }
        };
        
        commandInput.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                const inputValue = commandInput.value.trim();
                if (inputValue === '') {
                    commandInput.value = '';
                    return;
                }
                const commandText = inputValue;
                commandInput.value = '';
                
                let output = '';
                
                if (inChat) {
                    // Check ban before processing message
                    if (await checkBanAndExitIfNeeded()) {
                        return; // Kicked, don't process
                    }
                    
                    if (commandText.startsWith('/')) {
                        // Echo chat commands as regular command
                        const inputElement = document.createElement('div');
                        inputElement.className = 'command';
                        inputElement.textContent = `${prompt.textContent} ${commandText}`;
                        terminal.appendChild(inputElement);
                        
                        const [chatCmd, ...args] = commandText.slice(1).split(' ');
                        if (chatCmd === 'exit') {
                            const t = getTranslations();
                            inChat = false;
                            updatePrompt();
                            unloadChatMessages();
                            await setOffline();
                            output = t.obchatLeave;
                        } else if (chatCmd === 'nick') {
                            // Support /nick in chat, but check if set
                            const t = getTranslations();
                            if (args.length > 0) {
                                if (isNickSet) {
                                    output = t.nickAlreadySet;
                                } else {
                                    const oldNick = currentNick;
                                    currentNick = args.join(' ');
                                    localStorage.setItem('currentNick', currentNick); // Persist in localStorage
                                    isNickSet = true;
                                    await registerUser(currentNick);
                                    updatePrompt();
                                    if (oldNick === 'nk.exe2089' && currentNick !== 'nk.exe2089') {
                                        output = `Nickname changed from ${oldNick} to ${currentNick}. Admin privileges lost.`;
                                    } else {
                                        output = t.nickSet(currentNick);
                                    }
                                    await saveUserState();
                                }
                            } else {
                                output = t.nickUsage;
                            }
                        } else {
                            const t = getTranslations();
                            output = t.unknownChatCmd(chatCmd);
                        }
                    } else {
                        // General chat message - send to Firebase
                        await db.ref(CHAT_MESSAGES_PATH).push({
                            nick: currentNick,
                            text: commandText,
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        });
                        
                        // Bot moderation
                        handleBotModeration(commandText, currentNick);
                        
                        // Check ban after moderation
                        await checkBanAndExitIfNeeded();
                        
                        terminal.scrollTop = terminal.scrollHeight;
                        return; // No further processing
                    }
                } else {
                    // Normal command mode
                    const inputElement = document.createElement('div');
                    inputElement.className = 'command';
                    inputElement.textContent = `${prompt.textContent} ${commandText}`;
                    terminal.appendChild(inputElement);
                    
                    const [command, ...args] = commandText.split(' ');
                    if (localCommands[command]) {
                        output = await localCommands[command](args);
                    } else {
                        output = `Unknown command: ${command}`;
                    }
                }
                
                if (output !== '') {
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = output;
                    terminal.appendChild(outputElement);
                }
                
                saveTerminal();
                // Scroll to bottom
                terminal.scrollTop = terminal.scrollHeight;
            }
        });
        
        // Help button click
        helpBtn.addEventListener('click', async () => {
            await executeHelp();
        });
        
        // Focus the input on click anywhere
        document.body.addEventListener('click', () => {
            commandInput.focus();
        });
        
        // Terminal save fallback to localStorage
        function saveTerminal() {
            localStorage.setItem('pipelTerminal', terminal.innerHTML);
        }
        
        // Initial setup
        async function init() {
            // Load persisted nick from localStorage
            const savedNick = localStorage.getItem('currentNick');
            if (savedNick) {
                currentNick = savedNick;
                // Assume set if saved
                isNickSet = true;
            }
            await loadState();
            setupOnlineListener();
            const savedTerminal = localStorage.getItem('pipelTerminal');
            if (savedTerminal) {
                terminal.innerHTML = savedTerminal;
            } else {
                // No initial pinned help hint
                saveTerminal();
            }
            updateLanguage();
            updatePrompt();
            commandInput.focus(); // Ensure focus on mobile
        }
        init();
    </script>
</body>
    </html>
