<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipél Chat</title>
    <style>
        @font-face {
            font-family: 'CustomMono';
            src: url('font.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            background-color: #000;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            margin: 0;
            padding: 10px;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 14px;
            position: relative;
        }
        #terminal {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            margin-top: 5px;
        }
        #help-btn {
            color: #0f0;
            cursor: pointer;
            margin-right: 5px;
            white-space: nowrap;
            font-size: 14px;
            text-decoration: underline;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #help-btn:hover {
            color: #0ff;
        }
        #prompt {
            white-space: nowrap;
            margin-right: 5px;
            font-size: 14px;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #command-input {
            background-color: transparent;
            border: none;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            font-size: 14px;
            width: 100%;
            outline: none;
        }
        .output {
            white-space: pre-wrap;
            margin: 5px 0;
            color: #0f0;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .command {
            margin: 5px 0;
            color: #fff;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .chat-message {
            margin: 2px 0;
            color: #ff0;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .user-chat-message {
            margin: 2px 0;
            color: #0ff;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .notification {
            margin: 2px 0;
            color: #f0f;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .pinned {
            background-color: #111;
            border: 1px solid #333;
            padding: 5px;
            margin: 10px 0;
            font-weight: bold;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .bot-ban {
            margin: 2px 0;
            color: #f00;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .online {
            color: #0f0;
        }
        .offline {
            color: #888;
        }
        #top-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
        }
        .top-btn {
            color: #0f0;
            cursor: pointer;
            white-space: nowrap;
            font-size: 12px;
            text-decoration: underline;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: relative;
        }
        .top-btn:hover {
            color: #0ff;
        }
        .btn-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: #f00;
            color: #fff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chat-date {
            margin: 10px auto 5px auto;
            color: #0ff;
            font-weight: bold;
            text-align: center;
        }
        .chat-reminder {
            text-align: center;
            margin: 5px auto;
            color: #ff0;
        }
        .divider {
            text-align: center;
            margin: 10px auto;
            color: #888;
            font-size: 12px;
        }
        .chat-status {
            text-align: center;
            margin: 5px auto;
            color: #0f0;
            font-weight: bold;
        }
        .remaining-messages {
            text-align: center;
            margin: 5px auto;
            color: #f0f;
            font-style: italic;
        }
        .rules-link {
            text-align: center;
            margin: 5px auto;
            color: #0ff;
            cursor: pointer;
            text-decoration: underline;
        }
        .rules-link:hover {
            color: #ff0;
        }
        .welcome-message {
            position: fixed;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background-color: #111;
            border: 1px solid #333;
            padding: 10px;
            width: 250px;
            z-index: 1000;
            text-align: center;
        }
        .welcome-text {
            color: #0ff;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .close-welcome {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'CustomMono', 'Courier New', monospace;
            width: 100%;
        }
        .close-welcome:hover {
            background-color: #555;
        }
        @media (max-width: 600px) {
            body {
                padding: 5px;
                font-size: 12px;
            }
            #help-btn, #prompt, #command-input {
                font-size: 12px;
            }
            #terminal {
                padding-right: 5px;
            }
            #top-buttons {
                top: 5px;
                right: 5px;
                gap: 5px;
            }
            .top-btn {
                font-size: 10px;
            }
            .welcome-message {
                left: 5px;
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="welcome-message" class="welcome-message">
        <div class="welcome-text">Type 'help' for available commands</div>
        <button class="close-welcome" id="close-welcome">OK</button>
    </div>

    <div id="top-buttons">
        <span class="top-btn" id="exit-btn">[exit]</span>
        <span class="top-btn" id="clear-btn">[clear]</span>
        <span class="top-btn" id="obchat-btn">[obchat]</span>
        <span class="top-btn" id="notif-btn">[notif]</span>
    </div>
    <div id="terminal">
    </div>
    <div id="input-line">
        <span id="help-btn">[help]</span>
        <span id="prompt">user@localhost:~$</span>
        <input type="text" id="command-input" autofocus>
    </div>

    <!-- Firebase JS SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
    
    <!-- CryptoJS для шифрования -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>

    <script>
        // Firebase config
        const firebaseConfig = {
          apiKey: "AIzaSyDBBm7_VBqW0smF-7ecP1vaeTnMY68lc_w",
          authDomain: "my-terminal-chat-ecd4e.firebaseapp.com",
          projectId: "my-terminal-chat-ecd4e",
          storageBucket: "my-terminal-chat-ecd4e.firebasestorage.app",
          messagingSenderId: "401735371021",
          appId: "1:401735371021:web:81b1cf519130febee78844",
          measurementId: "G-SJ6VNQDS9M"
        }; 
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('command-input');
        const prompt = document.getElementById('prompt');
        const helpBtn = document.getElementById('help-btn');
        const exitBtn = document.getElementById('exit-btn');
        const clearBtn = document.getElementById('clear-btn');
        const obchatBtn = document.getElementById('obchat-btn');
        const notifBtn = document.getElementById('notif-btn');
        const welcomeMessage = document.getElementById('welcome-message');
        const closeWelcomeBtn = document.getElementById('close-welcome');
        
        // Ключ шифрования (можно изменить для большей безопасности)
        const ENCRYPTION_KEY = "pipel-chat-secret-key-2024";
        
        // Функции шифрования/дешифрования
        function encryptMessage(message) {
            try {
                return CryptoJS.AES.encrypt(message, ENCRYPTION_KEY).toString();
            } catch (error) {
                console.error('Encryption error:', error);
                return message; // Возвращаем исходное сообщение при ошибке
            }
        }

        function decryptMessage(encryptedMessage) {
            try {
                const bytes = CryptoJS.AES.decrypt(encryptedMessage, ENCRYPTION_KEY);
                const decrypted = bytes.toString(CryptoJS.enc.Utf8);
                return decrypted || "[не удалось расшифровать]";
            } catch (error) {
                console.error('Decryption error:', error);
                return "[ошибка расшифровки]";
            }
        }
        
        // Language support
        let currentLang = 'en';
        const translations = {
            en: {
                helpHint: "Type 'help' for available commands",
                help: `Available commands:
- help: Show this help message
- clear: Clear the terminal
- date: Show current date and time
- nick [name]: Set your nickname (only once) - registers you
- obchat: Enter general chat (type /exit to leave)
- tongue [lang]: Change language (en, ru)
- notif: Show notifications
- sms [nick|id] [message]: Send private message
- users_ip: Show online users list with nick and id`,
                chatHelp: `Chat commands:
- /exit: Leave the chat
- /sms [nick|id] [message]: Send private message`,
                adminHelp: `\nAdmin commands (🜲الشيطان🜲 only):
- ban [nick|id] [time] [reason]: Ban a user from entering chat
- unban [nick|id] [reason]: Unban a user from chat
- nickeditor [id] [new_nick]: Change user's nick by ID
- clear_chat (in chat): Clear all chat messages`,
                dateCmd: () => new Date().toString(),
                nickSet: (nick) => `Nickname set to ${nick}. You are now registered!`,
                nickAlreadySet: 'Nickname can only be set once.',
                nickExists: 'Such nickname already exists.',
                nickUsage: 'Usage: nick <name>',
                setNickFirst: 'Please set a nickname first using "nick <name>".',
                obchatLeave: 'Left general chat.',
                chatFull: 'Chat is full. Maximum 50 users.',
                unknownChatCmd: (cmd) => `Unknown chat command: /${cmd}`,
                unknownLang: (lang) => `Unknown language: ${lang}. Available: en, ru`,
                tongueUsage: 'Usage: tongue <lang> (en, ru)',
                onlyAdmin: 'This command is only available to the admin.',
                banUsage: 'Usage: ban <nick|id> <time> [reason]\nTime format: 30s, 50m, 78h, 79d (or 30с, 50м, 78ч, 79д)',
                banSet: (target, end, reason) => `User ${target} has been banned until ${end} for: ${reason}`,
                youBanned: (end, reason) => `You are banned from entering chat until ${end} for: ${reason}`,
                targetNotFound: (target) => `Target ${target} not found.`,
                unbanUsage: 'Usage: unban <nick|id] [reason]',
                unbanDone: (target, reason) => `User ${target} has been unbanned. Reason: ${reason}`,
                notBanned: (target) => `User ${target} is not banned.`,
                notifTitle: 'Notifications:\n',
                notifEmpty: 'No notifications.',
                nickeditorUsage: 'Usage: nickeditor <id> <new_nick>',
                idNotFound: 'ID not found.',
                nickTaken: 'New nick is already taken.',
                nickChanged: (id, old, neww) => `Nick for ${id} changed from ${old} to ${neww}.`,
                clearChat: 'Chat cleared by admin.',
                chatDate: (date, count, max) => `${date} (${count}/${max} online)`,
                exitReminder: 'Type /exit to leave the chat.',
                youInChat: 'You are in general chat.',
                remainingMessages: 'General chat remaining messages',
                onlineStatus: 'Online',
                offlineStatus: 'Offline',
                encryptedMessage: '[encrypted message]',
                rulesLink: 'General Chat Rules',
                smsUsage: 'Usage: sms <nick|id> <message>',
                smsSent: 'Private message sent successfully.',
                smsReceived: (from, message) => `PRIVATE MSG from ${from}: ${message}`,
                smsSelf: 'You cannot send message to yourself.',
                usersIpTitle: 'Online Users:\n',
                usersIpFormat: '\nNick\tID\n',
                noOnlineUsers: 'No online users.\n',
                welcomeMessage: "Type 'help' for available commands"
            },
            ru: {
                helpHint: "Введите 'help' для списка команд",
                help: `Доступные команды:
- help: Показать это сообщение помощи
- clear: Очистить терминал
- date: Показать текущую дату и время
- nick [имя]: Установить ваш никнейм (только один раз) - регистрирует вас
- obchat: Войти в общий чат (введите /exit для выхода)
- tongue [lang]: Сменить язык (en, ru)
- notif: Показать уведомления
- sms [ник|ид] [сообщение]: Отправить приватное сообщение
- users_ip: Показать список онлайн пользователей с ником и ид`,
                chatHelp: `Команды чата:
- /exit: Выйти из чата
- /sms [ник|ид] [сообщение]: Отправить приватное сообщение`,
                adminHelp: `\nКоманды администратора (только для 🜲الشيطان🜲):
- ban [ник|ид] [время] [причина]: Забанить пользователя от входа в чат
- unban [ник|ид] [причина]: Разбанить пользователя из чата
- nickeditor [ид] [новый_ник]: Изменить ник пользователя по ID
- clear_chat (в чате): Очистить все сообщения чата`,
                dateCmd: () => new Date().toLocaleString('ru-RU'),
                nickSet: (nick) => `Никнейм установлен: ${nick}. Вы теперь зарегистрированы!`,
                nickAlreadySet: 'Никнейм можно установить только один раз.',
                nickExists: 'Такой никнейм уже существует.',
                nickUsage: 'Использование: nick <имя>',
                setNickFirst: 'Сначала установите никнейм с помощью "nick <имя>".',
                obchatLeave: 'Вышли из общего чата.',
                chatFull: 'Чат заполнен. Максимум 50 пользователей.',
                unknownChatCmd: (cmd) => `Неизвестная команда чата: /${cmd}`,
                unknownLang: (lang) => `Неизвестный язык: ${lang}. Доступны: en, ru`,
                tongueUsage: 'Использование: tongue <lang> (en, ru)',
                onlyAdmin: 'Эта команда доступна только администратору.',
                banUsage: 'Использование: ban <ник|ид] <время] [причина]\nФормат времени: 30s, 50m, 78h, 79d (или 30с, 50м, 78ч, 79д)',
                banSet: (target, end, reason) => `Пользователь ${target} забанен до ${end} за: ${reason}`,
                youBanned: (end, reason) => `Вы забанены от входа в чат до ${end} за: ${reason}`,
                targetNotFound: (target) => `Цель ${target} не найдена.`,
                unbanUsage: 'Использование: unban <ник|ид] [причина разбана]',
                unbanDone: (target, reason) => `Пользователь ${target} разбанен. Причина: ${reason}`,
                notBanned: (target) => `Пользователь ${target} не забанен.`,
                notifTitle: 'Уведомления:\n',
                notifEmpty: 'Нет уведомлений.',
                nickeditorUsage: 'Использование: nickeditor <ид] <новый_ник>',
                idNotFound: 'ID не найден.',
                nickTaken: 'Новый ник уже занят.',
                nickChanged: (id, old, neww) => `Ник для ${id} изменен с ${old} на ${neww}.`,
                clearChat: 'Чат очищен администратором.',
                chatDate: (date, count, max) => `${date} (${count}/${max} онлайн)`,
                exitReminder: 'Введите /exit для выхода из чата.',
                youInChat: 'Вы в общем чате.',
                remainingMessages: 'В общем чате остались сообщения',
                onlineStatus: 'Онлайн',
                offlineStatus: 'Оффлайн',
                encryptedMessage: '[зашифрованное сообщение]',
                rulesLink: 'Правила общего чата',
                smsUsage: 'Использование: sms <ник|ид] <сообщение>',
                smsSent: 'Приватное сообщение отправлено успешно.',
                smsReceived: (from, message) => `ПРИВАТНОЕ СООБЩЕНИЕ от ${from}: ${message}`,
                smsSelf: 'Вы не можете отправить сообщение себе.',
                usersIpTitle: 'Онлайн пользователи:\n',
                usersIpFormat: '\nНик\tID\n',
                noOnlineUsers: 'Нет онлайн пользователей.\n',
                welcomeMessage: "Введите 'help' для списка команд"
            }
        };
        
        function updateLanguage() {
            const t = translations[currentLang];
            const helpHintEl = document.getElementById('help-hint');
            if (helpHintEl) helpHintEl.textContent = t.helpHint;
            
            // Update welcome message
            const welcomeText = welcomeMessage.querySelector('.welcome-text');
            if (welcomeText) {
                welcomeText.textContent = t.welcomeMessage;
            }
        }
        
        // Chat simulation
        let currentNick = 'user';
        let userId = null;
        let isNickSet = false;
        let inChat = false;
        let bannedUsers = new Map();
        let notifications = [];
        let unreadNotifications = 0;
        let unreadObchat = 0;
        let registeredUsers = new Map();
        let chatListener = null;
        let onlineUsers = new Set();
        let onlineRef = null;
        let onlineListener = null;
        let chatDateShown = false;
        let userStateListener = null;
        let welcomeClosed = localStorage.getItem('welcomeClosed') === 'true';
        const MAX_CHAT_USERS = 50;
        const MAX_DISPLAY_MESSAGES = 10;
        const LOAD_MESSAGES_COUNT = 30;
        
        // Firebase paths
        const USERS_PATH = 'users';
        const IDS_PATH = 'ids';
        const BANS_PATH = 'bans';
        const CHAT_MESSAGES_PATH = 'chat_messages';
        const ONLINE_USERS_PATH = 'online_users';
        
        // Generate unique ID
        async function generateUniqueID() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            while (true) {
                let id = '';
                for (let i = 0; i < 4; i++) {
                    id += chars[Math.floor(Math.random() * chars.length)];
                }
                const snap = await db.ref(`${IDS_PATH}/${id}`).once('value');
                if (!snap.exists()) {
                    return id;
                }
            }
        }
        
        // Load state from Firebase
        async function loadState() {
            try {
                const lowerNick = currentNick.toLowerCase();
                const userSnapshot = await db.ref(`${USERS_PATH}/${lowerNick}`).once('value');
                const userData = userSnapshot.val();
                if (userData) {
                    currentNick = userData.display_nick || currentNick;
                    userId = userData.id;
                    currentLang = userData.lang || 'en';
                    isNickSet = userData.is_nick_set || false;
                    notifications = userData.notifications || [];
                    notifications = notifications.slice(-50);
                    unreadNotifications = userData.unread_notifications || 0;
                    unreadObchat = userData.unread_obchat || 0;
                }
                if (isNickSet && !userId) {
                    userId = await generateUniqueID();
                    await db.ref(`${USERS_PATH}/${lowerNick}/id`).set(userId);
                    await db.ref(`${IDS_PATH}/${userId}`).set(lowerNick);
                }

                await loadBans();

                const regsSnapshot = await db.ref(USERS_PATH).once('value');
                if (regsSnapshot.exists()) {
                    regsSnapshot.forEach((childSnapshot) => {
                        const user = childSnapshot.val();
                        const key = childSnapshot.key;
                        registeredUsers.set(key, {
                            displayNick: user.display_nick,
                            id: user.id,
                            ip: user.ip,
                            regTime: new Date(user.reg_time).getTime(),
                            lastLogin: user.last_login ? new Date(user.last_login).getTime() : null
                        });
                    });
                }

                updateLanguage();
                updateButtonBadges();
                
                // Show welcome message if not closed
                if (!welcomeClosed) {
                    welcomeMessage.style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        // Save user state
        async function saveUserState() {
            try {
                const lowerNick = currentNick.toLowerCase();
                await db.ref(`${USERS_PATH}/${lowerNick}`).update({
                    display_nick: currentNick,
                    id: userId,
                    lang: currentLang,
                    is_nick_set: isNickSet,
                    notifications: notifications,
                    unread_notifications: unreadNotifications,
                    unread_obchat: unreadObchat,
                    ip: generateIP(),
                    last_login: new Date().toISOString()
                });
                if (userId) {
                    await db.ref(`${IDS_PATH}/${userId}`).set(lowerNick);
                }
            } catch (error) {
                console.error('Error saving user state:', error);
            }
        }

        // Update last login on online set
        async function setOnline() {
            const lowerNick = currentNick.toLowerCase();
            await db.ref(`${ONLINE_USERS_PATH}/${lowerNick}`).set(firebase.database.ServerValue.TIMESTAMP);
            await saveUserState();
            if (registeredUsers.has(lowerNick)) {
                registeredUsers.get(lowerNick).lastLogin = Date.now();
            }
        }

        async function setOffline() {
            const lowerNick = currentNick.toLowerCase();
            await db.ref(`${ONLINE_USERS_PATH}/${lowerNick}`).remove();
        }

        // Load bans
        async function loadBans() {
            try {
                const bansSnapshot = await db.ref(BANS_PATH).once('value');
                bannedUsers.clear();
                const toRemove = [];
                if (bansSnapshot.exists()) {
                    bansSnapshot.forEach((childSnapshot) => {
                        const ban = childSnapshot.val();
                        const endTime = new Date(ban.end_time).getTime();
                        if (Date.now() < endTime) {
                            bannedUsers.set(childSnapshot.key, {
                                endTime,
                                reason: ban.reason
                            });
                        } else {
                            toRemove.push(childSnapshot.key);
                        }
                    });
                }
                if (toRemove.length > 0) {
                    await Promise.all(toRemove.map(key => db.ref(`${BANS_PATH}/${key}`).remove()));
                }
            } catch (error) {
                console.error('Error loading bans:', error);
            }
        }

        // Save bans
        async function saveBans() {
            try {
                const updates = {};
                bannedUsers.forEach((ban, nick) => {
                    updates[`${BANS_PATH}/${nick}`] = {
                        end_time: new Date(ban.endTime).toISOString(),
                        reason: ban.reason
                    };
                });
                await db.ref().update(updates);
            } catch (error) {
                console.error('Error saving bans:', error);
            }
        }

        function addNotification(msg) {
            const timestamp = new Date().toLocaleString(getLocale());
            const notif = `${timestamp}: ${msg}`;
            notifications.push(notif);
            notifications = notifications.slice(-50);
            unreadNotifications++;
            updateButtonBadges();
            saveUserState();
        }

        function markNotificationsAsRead() {
            unreadNotifications = 0;
            updateButtonBadges();
            saveUserState();
        }

        function markObchatAsRead() {
            unreadObchat = 0;
            updateButtonBadges();
            saveUserState();
        }

        function updateButtonBadges() {
            // Update notif badge
            updateButtonBadge(notifBtn, unreadNotifications);
            
            // Update obchat badge
            updateButtonBadge(obchatBtn, unreadObchat);
        }

        function updateButtonBadge(button, count) {
            // Remove existing badge
            const existingBadge = button.querySelector('.btn-badge');
            if (existingBadge) {
                existingBadge.remove();
            }
            
            // Add new badge if count > 0
            if (count > 0) {
                const badge = document.createElement('span');
                badge.className = 'btn-badge';
                badge.textContent = count > 99 ? '99+' : count;
                button.appendChild(badge);
            }
        }

        async function registerUser(nick) {
            await saveUserState();
        }

        async function saveBan(lowerNick, banData) {
            bannedUsers.set(lowerNick, banData);
            await db.ref(`${BANS_PATH}/${lowerNick}`).set({
                end_time: new Date(banData.endTime).toISOString(),
                reason: banData.reason
            });
        }

        async function deleteBan(lowerNick) {
            bannedUsers.delete(lowerNick);
            await db.ref(`${BANS_PATH}/${lowerNick}`).remove();
        }

        // Load chat messages realtime with decryption
        function loadChatMessages() {
            if (chatListener) {
                db.ref(CHAT_MESSAGES_PATH).off('child_added', chatListener);
            }
            const chatRef = db.ref(CHAT_MESSAGES_PATH).limitToLast(LOAD_MESSAGES_COUNT);
            let messageCount = 0;
            chatListener = (snapshot) => {
                if (messageCount >= MAX_DISPLAY_MESSAGES) return;
                const msg = snapshot.val();
                
                // Дешифруем сообщение
                let decryptedText;
                try {
                    decryptedText = decryptMessage(msg.encrypted_text || msg.text);
                } catch (error) {
                    decryptedText = translations[currentLang].encryptedMessage;
                }
                
                const msgTime = new Date(msg.timestamp).toLocaleTimeString(getLocale(), {hour: '2-digit', minute: '2-digit'});
                const msgElement = document.createElement('div');
                msgElement.className = 'chat-message output';
                msgElement.textContent = `${msg.nick}[${msg.id}]: [${msgTime}] ${decryptedText}`;
                terminal.appendChild(msgElement);
                messageCount++;
                terminal.scrollTop = terminal.scrollHeight;
            };
            chatRef.on('child_added', chatListener);
        }

        function unloadChatMessages() {
            if (chatListener) {
                db.ref(CHAT_MESSAGES_PATH).off('child_added', chatListener);
                chatListener = null;
            }
        }

        // Listen for online users
        function setupOnlineListener() {
            onlineRef = db.ref(ONLINE_USERS_PATH);
            onlineListener = (snapshot) => {
                const data = snapshot.val() || {};
                onlineUsers.clear();
                Object.entries(data).forEach(([key, val]) => {
                    const lastSeen = val;
                    if (Date.now() - lastSeen < 30000) {
                        onlineUsers.add(key);
                    }
                });
                if (inChat) {
                    updatePrompt();
                    updateChatDate();
                }
            };
            onlineRef.on('value', onlineListener);
        }

        // Setup user state listener for SMS
        function setupUserStateListener() {
            const lowerNick = currentNick.toLowerCase();
            if (userStateListener) {
                db.ref(`${USERS_PATH}/${lowerNick}`).off('value', userStateListener);
            }
            userStateListener = (snapshot) => {
                const userData = snapshot.val();
                if (userData) {
                    const oldUnreadNotif = unreadNotifications;
                    const oldUnreadObchat = unreadObchat;
                    
                    unreadNotifications = userData.unread_notifications || 0;
                    unreadObchat = userData.unread_obchat || 0;
                    
                    if (unreadNotifications !== oldUnreadNotif || unreadObchat !== oldUnreadObchat) {
                        updateButtonBadges();
                    }
                }
            };
            db.ref(`${USERS_PATH}/${lowerNick}`).on('value', userStateListener);
        }

        // SMS system
        async function handleSmsCommand(args, isChat = false) {
            const t = getTranslations();
            if (args.length < 2) {
                return t.smsUsage;
            }
            
            const targetStr = args[0];
            const message = args.slice(1).join(' ');
            let targetLower;
            let targetDisplay = targetStr;
            
            // Find target
            if (/^[a-z0-9]{4}$/i.test(targetStr)) {
                const idSnap = await db.ref(`${IDS_PATH}/${targetStr.toLowerCase()}`).once('value');
                if (!idSnap.exists()) {
                    return t.targetNotFound(targetStr);
                }
                targetLower = idSnap.val();
                const userSnap = await db.ref(`${USERS_PATH}/${targetLower}`).once('value');
                if (userSnap.exists()) {
                    targetDisplay = userSnap.val().display_nick;
                }
            } else {
                targetLower = targetStr.toLowerCase();
                const userSnap = await db.ref(`${USERS_PATH}/${targetLower}`).once('value');
                if (!userSnap.exists()) {
                    return t.targetNotFound(targetStr);
                }
                targetDisplay = userSnap.val().display_nick;
            }
            
            // Check if self
            if (targetLower === currentNick.toLowerCase()) {
                return t.smsSelf;
            }
            
            // Send SMS
            const timestamp = new Date().toLocaleString(getLocale());
            const smsMessage = t.smsReceived(currentNick + '[' + userId + ']', message);
            const fullNotification = `${timestamp}: ${smsMessage}`;
            
            // Update target user's notifications
            const targetUserRef = db.ref(`${USERS_PATH}/${targetLower}`);
            const targetUserSnap = await targetUserRef.once('value');
            const targetUserData = targetUserSnap.val() || {};
            const targetNotifications = targetUserData.notifications || [];
            targetNotifications.push(fullNotification);
            
            await targetUserRef.update({
                notifications: targetNotifications.slice(-50),
                unread_notifications: (targetUserData.unread_notifications || 0) + 1
            });
            
            return t.smsSent;
        }

        function getTranslations() {
            return translations[currentLang];
        }
        
        function getLocale() {
            switch (currentLang) {
                case 'en': return 'en-US';
                case 'ru': return 'ru-RU';
                default: return 'en-US';
            }
        }
        
        function generateIP() {
            return `192.168.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
        }
        
        function parseDuration(str) {
            const match = str.match(/^(\d+)([smhdсмчд])$/i);
            if (!match) return null;
            const num = parseInt(match[1]);
            let unit = match[2].toLowerCase();
            switch (unit) {
                case 's':
                case 'с': return num * 1000;
                case 'm':
                case 'м': return num * 60 * 1000;
                case 'h':
                case 'ч': return num * 60 * 60 * 1000;
                case 'd':
                case 'д': return num * 24 * 60 * 60 * 1000;
                default: return null;
            }
        }
        
        function isAdmin() {
            return currentNick === '🜲الشيطان🜲';
        }
        
        async function checkBanAndExitIfNeeded() {
            const lowerNick = currentNick.toLowerCase();
            if (bannedUsers.has(lowerNick)) {
                const ban = bannedUsers.get(lowerNick);
                if (Date.now() < ban.endTime) {
                    inChat = false;
                    updatePrompt();
                    unloadChatMessages();
                    await setOffline();
                    const t = getTranslations();
                    const locale = getLocale();
                    const endStr = new Date(ban.endTime).toLocaleString(locale);
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = t.youBanned(endStr, ban.reason);
                    terminal.appendChild(outputElement);
                    saveTerminal();
                    terminal.scrollTop = terminal.scrollHeight;
                    return true;
                } else {
                    await deleteBan(lowerNick);
                }
            }
            return false;
        }
        
        async function executeHelp() {
            if (inChat) {
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} help`;
                terminal.appendChild(inputElement);
                
                const t = getTranslations();
                let helpText = t.chatHelp;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = helpText;
                terminal.appendChild(outputElement);
            } else {
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} help`;
                terminal.appendChild(inputElement);
                
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = helpText;
                terminal.appendChild(outputElement);
            }
            saveTerminal();
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function updatePrompt() {
            const t = getTranslations();
            if (inChat) {
                prompt.textContent = `${currentNick}[${userId}]@obchat (${onlineUsers.size}/${MAX_CHAT_USERS}): `;
            } else {
                prompt.textContent = `${currentNick}@localhost:~$`;
            }
        }

        async function showChatDate() {
            const t = getTranslations();
            terminal.innerHTML = '';
            const divider1 = document.createElement('div');
            divider1.className = 'divider';
            divider1.textContent = '//--//--//--//--//--//--//';
            terminal.appendChild(divider1);
            const status = document.createElement('div');
            status.className = 'chat-status';
            status.textContent = t.youInChat;
            terminal.appendChild(status);
            
            // Add rules link
            const rulesLink = document.createElement('div');
            rulesLink.className = 'rules-link';
            rulesLink.textContent = t.rulesLink;
            rulesLink.addEventListener('click', () => {
                window.open('rules.html', '_blank');
            });
            terminal.appendChild(rulesLink);
            
            const divider2 = document.createElement('div');
            divider2.className = 'divider';
            divider2.textContent = '//--//--//--//--//--//--//';
            terminal.appendChild(divider2);
            const today = new Date().toLocaleDateString(getLocale(), { 
                day: 'numeric', 
                month: 'long'
            });
            const dateElement = document.createElement('div');
            dateElement.className = 'chat-date';
            dateElement.textContent = t.chatDate(today, onlineUsers.size, MAX_CHAT_USERS);
            terminal.appendChild(dateElement);
            const countSnap = await db.ref(CHAT_MESSAGES_PATH).once('value');
            const messageCount = countSnap.numChildren();
            if (messageCount > 0) {
                const remaining = document.createElement('div');
                remaining.className = 'remaining-messages';
                remaining.textContent = t.remainingMessages;
                terminal.appendChild(remaining);
            }
            chatDateShown = true;
            terminal.scrollTop = terminal.scrollHeight;
        }

        function updateChatDate() {
            const dateElement = terminal.querySelector('.chat-date');
            if (dateElement) {
                const t = getTranslations();
                const today = new Date().toLocaleDateString(getLocale(), { 
                    day: 'numeric', 
                    month: 'long'
                });
                dateElement.textContent = t.chatDate(today, onlineUsers.size, MAX_CHAT_USERS);
            }
        }

        function showWelcomeMessage() {
            welcomeMessage.style.display = 'block';
            welcomeClosed = false;
            localStorage.setItem('welcomeClosed', 'false');
        }

        function hideWelcomeMessage() {
            welcomeMessage.style.display = 'none';
            welcomeClosed = true;
            localStorage.setItem('welcomeClosed', 'true');
        }
        
        const localCommands = {
            'help': () => {
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                return helpText;
            },
            'clear': (args) => {
                const pinned = terminal.querySelectorAll('.pinned');
                terminal.innerHTML = '';
                pinned.forEach(p => terminal.appendChild(p));
                inChat = false;
                chatDateShown = false;
                updatePrompt();
                updateLanguage();
                
                // Show welcome message after clear
                showWelcomeMessage();
                
                saveTerminal();
                return '';
            },
            'date': () => {
                const t = getTranslations();
                return t.dateCmd();
            },
            'nick': async (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    if (isNickSet) {
                        return t.nickAlreadySet;
                    }
                    const newNick = args.join(' ');
                    const newLowerNick = newNick.toLowerCase();
                    const existingSnapshot = await db.ref(`${USERS_PATH}/${newLowerNick}`).once('value');
                    if (existingSnapshot.exists()) {
                        return t.nickExists;
                    }
                    const id = await generateUniqueID();
                    const oldNick = currentNick;
                    currentNick = newNick;
                    userId = id;
                    localStorage.setItem('currentNick', currentNick);
                    isNickSet = true;
                    await db.ref(`${USERS_PATH}/${newLowerNick}`).set({
                        display_nick: newNick,
                        id: id,
                        lang: currentLang,
                        is_nick_set: true,
                        notifications: [],
                        unread_notifications: 0,
                        unread_obchat: 0,
                        ip: generateIP(),
                        reg_time: new Date().toISOString()
                    });
                    await db.ref(`${IDS_PATH}/${id}`).set(newLowerNick);
                    updatePrompt();
                    if (oldNick === '🜲الشيطان🜲' && currentNick !== '🜲الشيطان🜲') {
                        return `Nickname changed from ${oldNick} to ${currentNick}. Admin privileges lost.`;
                    }
                    await saveUserState();
                    return t.nickSet(currentNick);
                } else {
                    return t.nickUsage;
                }
            },
            'obchat': async () => {
                await loadBans();
                const t = getTranslations();
                if (!isNickSet) {
                    return t.setNickFirst;
                }
                if (!userId) {
                    return t.setNickFirst;
                }
                if (onlineUsers.size >= MAX_CHAT_USERS) {
                    return t.chatFull;
                }
                const lowerNick = currentNick.toLowerCase();
                if (bannedUsers.has(lowerNick)) {
                    const ban = bannedUsers.get(lowerNick);
                    if (Date.now() < ban.endTime) {
                        const locale = getLocale();
                        const endStr = new Date(ban.endTime).toLocaleString(locale);
                        return t.youBanned(endStr, ban.reason);
                    } else {
                        await deleteBan(lowerNick);
                    }
                }
                terminal.innerHTML = '';
                inChat = true;
                updatePrompt();
                await showChatDate();
                loadChatMessages();
                await setOnline();
                markObchatAsRead();
                return '';
            },
            'tongue': async (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    const lang = args[0].toLowerCase();
                    if (['en', 'ru'].includes(lang)) {
                        currentLang = lang;
                        await saveUserState();
                        updateLanguage();
                        updatePrompt();
                        return `Language changed to ${lang}`;
                    } else {
                        return t.unknownLang(lang);
                    }
                } else {
                    return t.tongueUsage;
                }
            },
            'notif': () => {
                const t = getTranslations();
                markNotificationsAsRead();
                if (notifications.length === 0) {
                    return t.notifEmpty;
                }
                let output = t.notifTitle;
                notifications.forEach(n => {
                    output += `${n}\n`;
                });
                return output;
            },
            'sms': async (args) => {
                return await handleSmsCommand(args);
            },
            'users_ip': () => {
                const t = getTranslations();
                let output = t.usersIpTitle;
                
                // Show all online users including current user
                let hasOnlineUsers = false;
                
                // Add current user first
                if (isNickSet && userId) {
                    output += `${currentNick}\t${userId}\n`;
                    hasOnlineUsers = true;
                }
                
                // Add other online users
                onlineUsers.forEach(lowerNick => {
                    if (registeredUsers.has(lowerNick) && lowerNick !== currentNick.toLowerCase()) {
                        const userData = registeredUsers.get(lowerNick);
                        output += `${userData.displayNick}\t${userData.id}\n`;
                        hasOnlineUsers = true;
                    }
                });
                
                if (!hasOnlineUsers) {
                    output += t.noOnlineUsers;
                }
                return output;
            },
            'ban': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 2) {
                    return t.banUsage;
                }
                const targetStr = args[0];
                let targetLower;
                if (/^[a-z0-9]{4}$/i.test(targetStr)) {
                    const idSnap = await db.ref(`${IDS_PATH}/${targetStr.toLowerCase()}`).once('value');
                    if (!idSnap.exists()) {
                        return t.targetNotFound(targetStr);
                    }
                    targetLower = idSnap.val();
                } else {
                    targetLower = targetStr.toLowerCase();
                }
                const timeStr = args[1];
                const reason = args.slice(2).join(' ') || 'No reason provided';
                const duration = parseDuration(timeStr);
                if (!duration) {
                    return t.banUsage;
                }
                const endTime = Date.now() + duration;
                const locale = getLocale();
                const endStr = new Date(endTime).toLocaleString(locale);
                const banData = { endTime, reason };
                await saveBan(targetLower, banData);
                const banMsg = t.banSet(targetStr, endStr, reason);
                addNotification(banMsg);
                if (targetLower === currentNick.toLowerCase() && inChat) {
                    checkBanAndExitIfNeeded();
                }
                return banMsg;
            },
            'unban': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 1) {
                    return t.unbanUsage;
                }
                const targetStr = args[0];
                let targetLower;
                if (/^[a-z0-9]{4}$/i.test(targetStr)) {
                    const idSnap = await db.ref(`${IDS_PATH}/${targetStr.toLowerCase()}`).once('value');
                    if (!idSnap.exists()) {
                        return t.targetNotFound(targetStr);
                    }
                    targetLower = idSnap.val();
                } else {
                    targetLower = targetStr.toLowerCase();
                }
                if (!bannedUsers.has(targetLower)) {
                    return t.notBanned(targetStr);
                }
                await deleteBan(targetLower);
                const reason = args.slice(1).join(' ') || 'No reason provided';
                const unbanMsg = t.unbanDone(targetStr, reason);
                addNotification(unbanMsg);
                return unbanMsg;
            },
            'nickeditor': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 2) {
                    return t.nickeditorUsage;
                }
                const id = args[0].toLowerCase();
                if (!/^[a-z0-9]{4}$/.test(id)) {
                    return t.idNotFound;
                }
                const newNick = args.slice(1).join(' ');
                if (!newNick) {
                    return t.nickeditorUsage;
                }
                const newLower = newNick.toLowerCase();
                const idRef = db.ref(`${IDS_PATH}/${id}`);
                const idSnap = await idRef.once('value');
                if (!idSnap.exists()) {
                    return t.idNotFound;
                }
                const oldLower = idSnap.val();
                const userRef = db.ref(`${USERS_PATH}/${oldLower}`);
                const userSnap = await userRef.once('value');
                if (!userSnap.exists()) {
                    return 'User data not found.';
                }
                const userData = userSnap.val();
                const oldDisplay = userData.display_nick;
                const newUserSnap = await db.ref(`${USERS_PATH}/${newLower}`).once('value');
                if (newUserSnap.exists()) {
                    return t.nickTaken;
                }
                await db.ref(`${USERS_PATH}/${oldLower}`).remove();
                await db.ref(`${USERS_PATH}/${newLower}`).set({
                    ...userData,
                    display_nick: newNick
                });
                await idRef.set(newLower);
                const oldOnlineRef = db.ref(`${ONLINE_USERS_PATH}/${oldLower}`);
                const newOnlineRef = db.ref(`${ONLINE_USERS_PATH}/${newLower}`);
                const oldOnlineSnap = await oldOnlineRef.once('value');
                if (oldOnlineSnap.exists()) {
                    const timestamp = oldOnlineSnap.val();
                    await oldOnlineRef.remove();
                    await newOnlineRef.set(timestamp);
                }
                if (oldLower === currentNick.toLowerCase()) {
                    currentNick = newNick;
                    localStorage.setItem('currentNick', newNick);
                    updatePrompt();
                }
                registeredUsers.delete(oldLower);
                registeredUsers.set(newLower, {
                    displayNick: newNick,
                    id: userData.id,
                    ip: userData.ip,
                    regTime: new Date(userData.reg_time).getTime(),
                    lastLogin: userData.last_login ? new Date(userData.last_login).getTime() : null
                });
                return t.nickChanged(id, oldDisplay, newNick);
            }
        };
        
        // Button event listeners
        exitBtn.addEventListener('click', async () => {
            if (inChat) {
                const t = getTranslations();
                inChat = false;
                updatePrompt();
                unloadChatMessages();
                await setOffline();
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = t.obchatLeave;
                terminal.appendChild(outputElement);
                saveTerminal();
                terminal.scrollTop = terminal.scrollHeight;
            }
        });

        clearBtn.addEventListener('click', () => {
            const args = [];
            localCommands['clear'](args);
        });

        obchatBtn.addEventListener('click', async () => {
            const args = [];
            const output = await localCommands['obchat']();
            if (output !== '') {
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = output;
                terminal.appendChild(outputElement);
                saveTerminal();
                terminal.scrollTop = terminal.scrollHeight;
            }
        });

        notifBtn.addEventListener('click', () => {
            const output = localCommands['notif']();
            if (output !== '') {
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} notif`;
                terminal.appendChild(inputElement);

                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = output;
                terminal.appendChild(outputElement);
                saveTerminal();
                terminal.scrollTop = terminal.scrollHeight;
            }
        });

        closeWelcomeBtn.addEventListener('click', () => {
            hideWelcomeMessage();
        });
        
        commandInput.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                const inputValue = commandInput.value.trim();
                if (inputValue === '') {
                    commandInput.value = '';
                    return;
                }
                const commandText = inputValue;
                commandInput.value = '';
                
                let output = '';
                
                if (inChat) {
                    if (await checkBanAndExitIfNeeded()) {
                        return;
                    }
                    
                    if (commandText.startsWith('/')) {
                        const inputElement = document.createElement('div');
                        inputElement.className = 'command';
                        inputElement.textContent = `${prompt.textContent} ${commandText}`;
                        terminal.appendChild(inputElement);
                        
                        const [chatCmd, ...args] = commandText.slice(1).split(' ');
                        if (chatCmd === 'exit') {
                            const t = getTranslations();
                            inChat = false;
                            updatePrompt();
                            unloadChatMessages();
                            await setOffline();
                            output = t.obchatLeave;
                        } else if (chatCmd === 'sms') {
                            output = await handleSmsCommand(args, true);
                        } else {
                            const t = getTranslations();
                            output = t.unknownChatCmd(chatCmd);
                        }
                    } else {
                        // ШИФРУЕМ сообщение перед отправкой в Firebase
                        const encryptedText = encryptMessage(commandText);
                        
                        await db.ref(CHAT_MESSAGES_PATH).push({
                            nick: currentNick,
                            id: userId,
                            text: "[encrypted]", // Старое поле для совместимости
                            encrypted_text: encryptedText, // Новое зашифрованное поле
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        });
                        
                        await checkBanAndExitIfNeeded();
                        
                        terminal.scrollTop = terminal.scrollHeight;
                        return;
                    }
                } else {
                    const inputElement = document.createElement('div');
                    inputElement.className = 'command';
                    inputElement.textContent = `${prompt.textContent} ${commandText}`;
                    terminal.appendChild(inputElement);
                    
                    const [command, ...args] = commandText.split(' ');
                    if (localCommands[command]) {
                        output = await localCommands[command](args);
                    } else {
                        output = `Unknown command: ${command}`;
                    }
                }
                
                if (output !== '') {
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = output;
                    terminal.appendChild(outputElement);
                }
                
                saveTerminal();
                terminal.scrollTop = terminal.scrollHeight;
            }
        });
        
        helpBtn.addEventListener('click', async () => {
            await executeHelp();
        });
        
        document.body.addEventListener('click', () => {
            commandInput.focus();
        });
        
        function saveTerminal() {
            localStorage.setItem('pipelTerminal', terminal.innerHTML);
        }
        
        async function init() {
            const savedNick = localStorage.getItem('currentNick');
            if (savedNick) {
                currentNick = savedNick;
                isNickSet = true;
            }
            await loadState();
            setupOnlineListener();
            setupUserStateListener();
            const savedTerminal = localStorage.getItem('pipelTerminal');
            if (savedTerminal) {
                terminal.innerHTML = savedTerminal;
            } else {
                saveTerminal();
            }
            updateLanguage();
            updatePrompt();
            commandInput.focus();
        }
        init();
    </script>
</body>
</html>
