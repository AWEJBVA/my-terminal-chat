<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipél Chat</title>
    <style>
        @font-face {
            font-family: 'CustomMono';
            src: url('font.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            background-color: #000;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            margin: 0;
            padding: 10px;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 14px;
        }
        #terminal {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            margin-top: 5px;
        }
        #prompt {
            white-space: nowrap;
            margin-right: 5px;
            font-size: 14px;
        }
        #command-input {
            background-color: transparent;
            border: none;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            font-size: 14px;
            width: 100%;
            outline: none;
        }
        .output {
            white-space: pre-wrap;
            margin: 5px 0;
            color: #0f0; /* Зеленый для вывода */
        }
        .command {
            margin: 5px 0;
            color: #fff;
        }
        .chat-message {
            margin: 2px 0;
            color: #ff0; /* Желтый для чат-сообщений */
        }
        .user-chat-message {
            margin: 2px 0;
            color: #0ff; /* Голубой для сообщений пользователя */
        }
        .notification {
            margin: 2px 0;
            color: #f0f; /* Фиолетовый для уведомлений */
        }
        .pinned {
            background-color: #111;
            border: 1px solid #333;
            padding: 5px;
            margin: 10px 0;
            font-weight: bold;
        }
        .bot-ban {
            margin: 2px 0;
            color: #f00; /* Красный для бана бота */
        }
        @media (max-width: 600px) {
            body {
                padding: 5px;
                font-size: 12px;
            }
            #prompt, #command-input {
                font-size: 12px;
            }
            #terminal {
                padding-right: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="terminal">
    </div>
    <div id="input-line">
        <span id="prompt">user@localhost:~$</span>
        <input type="text" id="command-input" autofocus>
    </div>

    <script>
        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('command-input');
        const prompt = document.getElementById('prompt');
        
        // Language support
        let currentLang = 'en';
        const translations = {
            en: {
                helpHint: "Type 'help' for available commands",
                help: `Available commands:
- help: Show this help message
- clear: Clear the terminal
- date: Show current date and time
- nick [name]: Set your nickname (only once)
- obchat: Enter general chat (type /exit to leave)
- tongue [lang]: Change language (en, ru, zh)
- notif: Show notifications`,
                adminHelp: `\nAdmin commands (nk.exe2089 only):
- ban [nick] [time] [reason]: Ban a user from entering chat
- unban [nick] [reason]: Unban a user from chat
- users_ip: Show users in general chat and recent logins with IP, nick, and entry time
- bot [on|off]: Toggle moderation bot in chat
- prov: Check bot status`,
                dateCmd: () => new Date().toString(),
                nickSet: (nick) => `Nickname set to ${nick}`,
                nickAlreadySet: 'Nickname can only be set once.',
                nickUsage: 'Usage: nick <name>',
                setNickFirst: 'Please set a nickname first using "nick <name>".',
                obchatEnter: 'Entered general chat. Type messages to chat. Use /exit to leave.',
                obchatLeave: 'Left general chat.',
                unknownChatCmd: (cmd) => `Unknown chat command: /${cmd}`,
                unknownLang: (lang) => `Unknown language: ${lang}. Available: en, ru, zh`,
                tongueUsage: 'Usage: tongue <lang> (en, ru, zh)',
                onlyAdmin: 'This command is only available to the admin.',
                banUsage: 'Usage: ban <nick> <time> [reason]\nTime format: 30s, 50m, 78h, 79d (or 30с, 50м, 78ч, 79д)',
                banSet: (nick, end, reason) => `User ${nick} has been banned until ${end} for: ${reason}`,
                youBanned: (end, reason) => `You are banned from entering chat until ${end} for: ${reason}`,
                unbanUsage: 'Usage: unban <nick> [reason]',
                unbanDone: (nick, reason) => `User ${nick} has been unbanned. Reason: ${reason}`,
                notBanned: (nick) => `User ${nick} is not banned.`,
                usersIpTitle: 'Users IP List\nNick\tIP\tEntry Time\n',
                botOn: 'Moderation bot enabled in chat.',
                botOff: 'Moderation bot disabled in chat.',
                botStatusOn: 'Bot is ON.',
                botStatusOff: 'Bot is OFF.',
                botInvalid: 'Usage: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} banned for 5 minutes for insults to relatives.`,
                notifTitle: 'Notifications:\n',
                notifEmpty: 'No notifications.'
            },
            ru: {
                helpHint: "Введите 'help' для списка команд",
                help: `Доступные команды:
- help: Показать это сообщение помощи
- clear: Очистить терминал
- date: Показать текущую дату и время
- nick [имя]: Установить ваш никнейм (только один раз)
- obchat: Войти в общий чат (введите /exit для выхода)
- tongue [lang]: Сменить язык (en, ru, zh)
- notif: Показать уведомления`,
                adminHelp: `\nКоманды администратора (только для nk.exe2089):
- ban [ник] [время] [причина]: Забанить пользователя от входа в чат
- unban [ник] [причина]: Разбанить пользователя из чата
- users_ip: Показать пользователей в общем чате и недавние входы с IP, ником и временем входа
- bot [on|off]: Включить/выключить модерационного бота в чате
- prov: Проверить статус бота`,
                dateCmd: () => new Date().toLocaleString('ru-RU'),
                nickSet: (nick) => `Никнейм установлен: ${nick}`,
                nickAlreadySet: 'Никнейм можно установить только один раз.',
                nickUsage: 'Использование: nick <имя>',
                setNickFirst: 'Сначала установите никнейм с помощью "nick <имя>".',
                obchatEnter: 'Вошли в общий чат. Пишите сообщения для общения. Используйте /exit для выхода.',
                obchatLeave: 'Вышли из общего чата.',
                unknownChatCmd: (cmd) => `Неизвестная команда чата: /${cmd}`,
                unknownLang: (lang) => `Неизвестный язык: ${lang}. Доступны: en, ru, zh`,
                tongueUsage: 'Использование: tongue <lang> (en, ru, zh)',
                onlyAdmin: 'Эта команда доступна только администратору.',
                banUsage: 'Использование: ban <ник> <время> [причина]\nФормат времени: 30s, 50m, 78h, 79d (или 30с, 50м, 78ч, 79д)',
                banSet: (nick, end, reason) => `Пользователь ${nick} забанен до ${end} за: ${reason}`,
                youBanned: (end, reason) => `Вы забанены от входа в чат до ${end} за: ${reason}`,
                unbanUsage: 'Использование: unban <ник> [причина разбана]',
                unbanDone: (nick, reason) => `Пользователь ${nick} разбанен. Причина: ${reason}`,
                notBanned: (nick) => `Пользователь ${nick} не забанен.`,
                usersIpTitle: 'Список IP пользователей\nНик\tIP\tВремя входа\n',
                botOn: 'Модерационный бот включен в чате.',
                botOff: 'Модерационный бот выключен в чате.',
                botStatusOn: 'Бот включен.',
                botStatusOff: 'Бот выключен.',
                botInvalid: 'Использование: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} забанен на 5 минут за оскорбления родных.`,
                notifTitle: 'Уведомления:\n',
                notifEmpty: 'Нет уведомлений.'
            },
            zh: {
                helpHint: "输入 'help' 查看可用命令",
                help: `可用命令:
- help: 显示此帮助消息
- clear: 清空终端
- date: 显示当前日期和时间
- nick [name]: 设置您的昵称 (仅一次)
- obchat: 进入通用聊天 (输入 /exit 退出)
- tongue [lang]: 更改语言 (en, ru, zh)
- notif: 显示通知`,
                adminHelp: `\n管理员命令 (仅 nk.exe2089):
- ban [nick] [time] [reason]: 禁止用户进入聊天
- unban [nick] [reason]: 解除用户聊天禁令
- users_ip: 显示通用聊天中的用户和最近登录的 IP、昵称和进入时间
- bot [on|off]: 切换聊天中的 moderation bot
- prov: 检查 bot 状态`,
                dateCmd: () => new Date().toLocaleString('zh-CN'),
                nickSet: (nick) => `昵称设置为 ${nick}`,
                nickAlreadySet: '昵称只能设置一次。',
                nickUsage: '用法: nick <name>',
                setNickFirst: '请先使用 "nick <name>" 设置昵称。',
                obchatEnter: '已进入通用聊天。输入消息聊天。使用 /exit 退出。',
                obchatLeave: '已离开通用聊天。',
                unknownChatCmd: (cmd) => `未知聊天命令: /${cmd}`,
                unknownLang: (lang) => `未知语言: ${lang}。可用: en, ru, zh`,
                tongueUsage: '用法: tongue <lang> (en, ru, zh)',
                onlyAdmin: '此命令仅管理员可用。',
                banUsage: '用法: ban <nick> <time> [reason]\n时间格式: 30s, 50m, 78h, 79d (或 30с, 50м, 78ч, 79д)',
                banSet: (nick, end, reason) => `用户 ${nick} 被禁止直到 ${end} 原因: ${reason}`,
                youBanned: (end, reason) => `您被禁止进入聊天直到 ${end} 原因: ${reason}`,
                unbanUsage: '用法: unban <nick> [reason]',
                unbanDone: (nick, reason) => `用户 ${nick} 已解除禁令。原因: ${reason}`,
                notBanned: (nick) => `用户 ${nick} 未被禁止。`,
                usersIpTitle: '用户 IP 列表\n昵称\tIP\t进入时间\n',
                botOn: '聊天 moderation bot 已启用。',
                botOff: '聊天 moderation bot 已禁用。',
                botStatusOn: 'Bot 已开启。',
                botStatusOff: 'Bot 已关闭。',
                botInvalid: '用法: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} 被禁 5 分钟因 insults to relatives。`,
                notifTitle: '通知:\n',
                notifEmpty: '无通知。'
            }
        };
        
        function updateLanguage() {
            const t = translations[currentLang];
            const helpHintEl = document.getElementById('help-hint');
            if (helpHintEl) helpHintEl.textContent = t.helpHint;
        }
        
        // Chat simulation
        let currentNick = 'user';
        let isNickSet = false;
        let inChat = false;
        let bannedUsers = new Map();
        let botEnabled = false;
        let notifications = [];
        
        // Persistence - all in localStorage
        function loadState() {
            const savedNick = localStorage.getItem('pipelNick');
            if (savedNick && savedNick !== 'user') {
                currentNick = savedNick;
                isNickSet = true;
            }
            const savedLang = localStorage.getItem('pipelLang');
            if (savedLang && translations[savedLang]) currentLang = savedLang;
            
            const savedBot = localStorage.getItem('pipelBotEnabled');
            if (savedBot !== null) botEnabled = JSON.parse(savedBot);
            
            const savedNotifs = localStorage.getItem('pipelNotifications');
            if (savedNotifs) {
                try {
                    notifications = JSON.parse(savedNotifs);
                    notifications = notifications.slice(-50); // Keep only last 50
                } catch (e) {
                    console.error('Failed to load notifications:', e);
                    notifications = [];
                }
            }

            const savedIsNickSet = localStorage.getItem('pipelIsNickSet');
            if (savedIsNickSet !== null) {
                isNickSet = JSON.parse(savedIsNickSet);
            } else if (savedNick && savedNick !== 'user') {
                isNickSet = true;
            }
        }
        
        function saveNick() {
            localStorage.setItem('pipelNick', currentNick);
        }
        
        function saveIsNickSet() {
            localStorage.setItem('pipelIsNickSet', JSON.stringify(isNickSet));
        }
        
        function saveLang() {
            localStorage.setItem('pipelLang', currentLang);
        }
        
        function loadBans() {
            const savedBans = localStorage.getItem('pipelBans');
            if (savedBans) {
                try {
                    const bans = JSON.parse(savedBans);
                    bannedUsers = new Map(bans.map(([k, v]) => [k, v]));
                    for (const [nick, ban] of bannedUsers.entries()) {
                        if (Date.now() >= ban.endTime) {
                            bannedUsers.delete(nick);
                        }
                    }
                    saveBans(); // Update storage
                } catch (e) {
                    console.error('Failed to load bans:', e);
                }
            }
        }
        
        function saveBans() {
            const bansArray = Array.from(bannedUsers.entries());
            localStorage.setItem('pipelBans', JSON.stringify(bansArray));
        }
        
        function saveBotState(enabled) {
            localStorage.setItem('pipelBotEnabled', JSON.stringify(enabled));
            botEnabled = enabled;
        }
        
        function addNotification(msg) {
            const timestamp = new Date().toLocaleString(getLocale());
            const notif = `${timestamp}: ${msg}`;
            notifications.push(notif);
            notifications = notifications.slice(-50); // Keep only last 50
            localStorage.setItem('pipelNotifications', JSON.stringify(notifications));
        }
        
        function saveBan(nick, banData) {
            const lowerNick = nick.toLowerCase();
            bannedUsers.set(lowerNick, banData);
            saveBans();
        }
        
        function deleteBan(nick) {
            const lowerNick = nick.toLowerCase();
            bannedUsers.delete(lowerNick);
            saveBans();
        }
        
        function saveTerminal() {
            localStorage.setItem('pipelTerminal', terminal.innerHTML);
        }
        
        function getTranslations() {
            return translations[currentLang];
        }
        
        function getLocale() {
            switch (currentLang) {
                case 'en': return 'en-US';
                case 'ru': return 'ru-RU';
                case 'zh': return 'zh-CN';
                default: return 'en-US';
            }
        }
        
        function generateIP() {
            return `192.168.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
        }
        
        function parseDuration(str) {
            const match = str.match(/^(\d+)([smhdсмчд])$/i);
            if (!match) return null;
            const num = parseInt(match[1]);
            let unit = match[2].toLowerCase();
            switch (unit) {
                case 's':
                case 'с': return num * 1000;
                case 'm':
                case 'м': return num * 60 * 1000;
                case 'h':
                case 'ч': return num * 60 * 60 * 1000;
                case 'd':
                case 'д': return num * 24 * 60 * 60 * 1000;
                default: return null;
            }
        }
        
        function isAdmin() {
            return currentNick === 'nk.exe2089';
        }
        
        function handleBotModeration(message, senderNick) {
            // Test mode - no action for now
            console.log('Bot test: message checked');
        }
        
        function checkBanAndExitIfNeeded() {
            const lowerNick = currentNick.toLowerCase();
            if (bannedUsers.has(lowerNick)) {
                const ban = bannedUsers.get(lowerNick);
                if (Date.now() < ban.endTime) {
                    inChat = false;
                    updatePrompt();
                    const t = getTranslations();
                    const locale = getLocale();
                    const endStr = new Date(ban.endTime).toLocaleString(locale);
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = t.youBanned(endStr, ban.reason);
                    terminal.appendChild(outputElement);
                    saveTerminal();
                    terminal.scrollTop = terminal.scrollHeight;
                    return true; // Kicked
                } else {
                    deleteBan(lowerNick);
                }
            }
            return false; // Not kicked
        }
        
        // Local commands
        function updatePrompt() {
            const t = getTranslations();
            if (inChat) {
                prompt.textContent = `${currentNick}@obchat: `;
            } else {
                prompt.textContent = `${currentNick}@localhost:~$`;
            }
        }
        
        const localCommands = {
            'help': () => {
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                return helpText;
            },
            'clear': (args) => {
                // Clear outputs but keep pinned
                const pinned = terminal.querySelectorAll('.pinned');
                terminal.innerHTML = '';
                pinned.forEach(p => terminal.appendChild(p));
                inChat = false;
                updatePrompt();
                updateLanguage();
                saveTerminal();
                return '';
            },
            'date': () => {
                const t = getTranslations();
                return t.dateCmd();
            },
            'nick': (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    if (isNickSet) {
                        return t.nickAlreadySet;
                    }
                    const oldNick = currentNick;
                    currentNick = args.join(' ');
                    saveNick();
                    isNickSet = true;
                    saveIsNickSet();
                    updatePrompt();
                    // If was admin, check if new is admin too
                    if (oldNick === 'nk.exe2089' && currentNick !== 'nk.exe2089') {
                        return `Nickname changed from ${oldNick} to ${currentNick}. Admin privileges lost.`;
                    }
                    return t.nickSet(currentNick);
                } else {
                    return t.nickUsage;
                }
            },
            'obchat': () => {
                loadBans(); // Ensure bans are loaded
                const t = getTranslations();
                if (!isNickSet) {
                    return t.setNickFirst;
                }
                const lowerNick = currentNick.toLowerCase();
                if (bannedUsers.has(lowerNick)) {
                    const ban = bannedUsers.get(lowerNick);
                    if (Date.now() < ban.endTime) {
                        const locale = getLocale();
                        const endStr = new Date(ban.endTime).toLocaleString(locale);
                        return t.youBanned(endStr, ban.reason);
                    } else {
                        deleteBan(lowerNick);
                    }
                }
                inChat = true;
                updatePrompt();
                return t.obchatEnter;
            },
            'tongue': (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    const lang = args[0].toLowerCase();
                    if (['en', 'ru', 'zh'].includes(lang)) {
                        currentLang = lang;
                        saveLang();
                        updateLanguage();
                        updatePrompt();
                        return `Language changed to ${lang}`;
                    } else {
                        return t.unknownLang(lang);
                    }
                } else {
                    return t.tongueUsage;
                }
            },
            'notif': () => {
                const t = getTranslations();
                if (notifications.length === 0) {
                    return t.notifEmpty;
                }
                let output = t.notifTitle;
                notifications.forEach(n => {
                    output += `${n}\n`;
                });
                return output;
            },
            'ban': (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 2) {
                    return t.banUsage;
                }
                const nick = args[0];
                const timeStr = args[1];
                const reason = args.slice(2).join(' ') || 'No reason provided';
                const duration = parseDuration(timeStr);
                if (!duration) {
                    return t.banUsage;
                }
                const endTime = Date.now() + duration;
                const locale = getLocale();
                const endStr = new Date(endTime).toLocaleString(locale);
                const banData = { endTime, reason };
                saveBan(nick, banData);
                const banMsg = t.banSet(nick, endStr, reason);
                addNotification(banMsg);
                // Check if self-banned and in chat
                if (nick.toLowerCase() === currentNick.toLowerCase() && inChat) {
                    checkBanAndExitIfNeeded();
                }
                return banMsg;
            },
            'unban': (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 1) {
                    return t.unbanUsage;
                }
                const nick = args[0];
                const reason = args.slice(1).join(' ') || 'No reason provided';
                const lowerNick = nick.toLowerCase();
                if (!bannedUsers.has(lowerNick)) {
                    return t.notBanned(nick);
                }
                deleteBan(lowerNick);
                const unbanMsg = t.unbanDone(nick, reason);
                addNotification(unbanMsg);
                return unbanMsg;
            },
            'bot': (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 1) {
                    return t.botInvalid;
                }
                const action = args[0].toLowerCase();
                if (action === 'on') {
                    saveBotState(true);
                    return t.botOn;
                } else if (action === 'off') {
                    saveBotState(false);
                    return t.botOff;
                } else {
                    return t.botInvalid;
                }
            },
            'prov': () => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                return botEnabled ? t.botStatusOn : t.botStatusOff;
            },
            'users_ip': () => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                let users = [];
                if (inChat) {
                    users.push({
                        nick: currentNick,
                        ip: generateIP(),
                        entryTime: Date.now() - Math.random() * 60000 // recent 1 min
                    });
                }
                const numSim = Math.floor(Math.random() * 4) + 2; // 2-5 simulated
                for (let i = 0; i < numSim; i++) {
                    let simNick;
                    do {
                        simNick = 'user' + Math.floor(Math.random() * 100); // Generic users
                    } while (users.some(u => u.nick === simNick)); // avoid duplicate
                    users.push({
                        nick: simNick,
                        ip: generateIP(),
                        entryTime: Date.now() - Math.random() * 86400000 // up to 1 day ago
                    });
                }
                users.sort((a, b) => b.entryTime - a.entryTime);
                let output = t.usersIpTitle;
                users.forEach(u => {
                    output += `${u.nick}\t${u.ip}\t${new Date(u.entryTime).toLocaleString(getLocale())}\n`;
                });
                return output;
            }
        };
        
        commandInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const commandText = commandInput.value.trim();
                commandInput.value = '';
                
                let output = '';
                
                if (inChat) {
                    // Check ban before processing message
                    if (checkBanAndExitIfNeeded()) {
                        return; // Kicked, don't process
                    }
                    
                    if (commandText.startsWith('/')) {
                        // Echo chat commands as regular command
                        const inputElement = document.createElement('div');
                        inputElement.className = 'command';
                        inputElement.textContent = `${prompt.textContent} ${commandText}`;
                        terminal.appendChild(inputElement);
                        
                        const [chatCmd, ...args] = commandText.slice(1).split(' ');
                        if (chatCmd === 'exit') {
                            const t = getTranslations();
                            inChat = false;
                            updatePrompt();
                            output = t.obchatLeave;
                        } else if (chatCmd === 'nick') {
                            // Support /nick in chat, but check if set
                            const t = getTranslations();
                            if (args.length > 0) {
                                if (isNickSet) {
                                    output = t.nickAlreadySet;
                                } else {
                                    const oldNick = currentNick;
                                    currentNick = args.join(' ');
                                    saveNick();
                                    isNickSet = true;
                                    saveIsNickSet();
                                    updatePrompt();
                                    if (oldNick === 'nk.exe2089' && currentNick !== 'nk.exe2089') {
                                        output = `Nickname changed from ${oldNick} to ${currentNick}. Admin privileges lost.`;
                                    } else {
                                        output = t.nickSet(currentNick);
                                    }
                                }
                            } else {
                                output = t.nickUsage;
                            }
                        } else {
                            const t = getTranslations();
                            output = t.unknownChatCmd(chatCmd);
                        }
                    } else {
                        // Chat message - no echo, just formatted message
                        const t = getTranslations();
                        const msgElement = document.createElement('div');
                        msgElement.className = 'user-chat-message output';
                        msgElement.textContent = `${currentNick}: ${commandText}`;
                        terminal.appendChild(msgElement);
                        
                        // Simulate showing to other users (log it)
                        console.log(`Message from ${currentNick} visible to all users: ${commandText}`);
                        
                        // Bot moderation
                        handleBotModeration(commandText, currentNick);
                        
                        // Check ban after moderation
                        checkBanAndExitIfNeeded();
                        
                        saveTerminal();
                        terminal.scrollTop = terminal.scrollHeight;
                        return; // No further processing
                    }
                } else {
                    // Normal command mode
                    const inputElement = document.createElement('div');
                    inputElement.className = 'command';
                    inputElement.textContent = `${prompt.textContent} ${commandText}`;
                    terminal.appendChild(inputElement);
                    
                    const [command, ...args] = commandText.split(' ');
                    if (localCommands[command]) {
                        output = localCommands[command](args);
                    } else {
                        output = `Unknown command: ${command}`;
                    }
                }
                
                if (output !== '') {
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = output;
                    terminal.appendChild(outputElement);
                }
                
                saveTerminal();
                // Scroll to bottom
                terminal.scrollTop = terminal.scrollHeight;
            }
        });
        
        // Focus the input on click anywhere
        document.body.addEventListener('click', () => {
            commandInput.focus();
        });
        
        // Initial setup
        function init() {
            loadState();
            loadBans();
            const savedTerminal = localStorage.getItem('pipelTerminal');
            if (savedTerminal) {
                terminal.innerHTML = savedTerminal;
            } else {
                const pinned = document.createElement('div');
                pinned.className = 'output pinned';
                pinned.id = 'help-hint';
                pinned.textContent = translations[currentLang].helpHint;
                terminal.appendChild(pinned);
                saveTerminal();
            }
            updateLanguage();
            updatePrompt();
            commandInput.focus(); // Ensure focus on mobile
        }
        init();
    </script>
</body>
    </html>
