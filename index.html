<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipél Chat</title>
    <style>
        @font-face {
            font-family: 'CustomMono';
            src: url('font.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            background-color: #000;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            margin: 0;
            padding: 10px;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 14px;
            position: relative;
        }
        #terminal {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            margin-top: 5px;
        }
        #help-btn {
            color: #0f0;
            cursor: pointer;
            margin-right: 5px;
            white-space: nowrap;
            font-size: 14px;
            text-decoration: underline;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #help-btn:hover {
            color: #0ff;
        }
        #prompt {
            white-space: nowrap;
            margin-right: 5px;
            font-size: 14px;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #command-input {
            background-color: transparent;
            border: none;
            color: #fff;
            font-family: 'CustomMono', 'Courier New', monospace;
            font-size: 14px;
            width: 100%;
            outline: none;
        }
        .output {
            white-space: pre-wrap;
            margin: 5px 0;
            color: #0f0; /* Зеленый для вывода */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .command {
            margin: 5px 0;
            color: #fff;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .chat-message {
            margin: 2px 0;
            color: #ff0; /* Желтый для чат-сообщений */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .user-chat-message {
            margin: 2px 0;
            color: #0ff; /* Голубой для сообщений пользователя */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .notification {
            margin: 2px 0;
            color: #f0f; /* Фиолетовый для уведомлений */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .pinned {
            background-color: #111;
            border: 1px solid #333;
            padding: 5px;
            margin: 10px 0;
            font-weight: bold;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .bot-ban {
            margin: 2px 0;
            color: #f00; /* Красный для бана бота */
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .online {
            color: #0f0;
        }
        .offline {
            color: #888;
        }
        #top-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
        }
        .top-btn {
            color: #0f0;
            cursor: pointer;
            white-space: nowrap;
            font-size: 12px;
            text-decoration: underline;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .top-btn:hover {
            color: #0ff;
        }
        .chat-date {
            margin: 10px auto 5px auto;
            color: #0ff;
            font-weight: bold;
            text-align: center;
        }
        .chat-reminder {
            text-align: center;
            margin: 5px auto;
            color: #ff0;
        }
        .divider {
            text-align: center;
            margin: 10px auto;
            color: #888;
            font-size: 12px;
        }
        .chat-status {
            text-align: center;
            margin: 5px auto;
            color: #0f0;
            font-weight: bold;
        }
        .remaining-messages {
            text-align: center;
            margin: 5px auto;
            color: #f0f;
            font-style: italic;
        }
        @media (max-width: 600px) {
            body {
                padding: 5px;
                font-size: 12px;
            }
            #help-btn, #prompt, #command-input {
                font-size: 12px;
            }
            #terminal {
                padding-right: 5px;
            }
            #top-buttons {
                top: 5px;
                right: 5px;
                gap: 5px;
            }
            .top-btn {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="top-buttons">
        <span class="top-btn" id="exit-btn">[exit]</span>
        <span class="top-btn" id="clear-btn">[clear]</span>
        <span class="top-btn" id="obchat-btn">[obchat]</span>
        <span class="top-btn" id="notif-btn">[notif]</span>
    </div>
    <div id="terminal">
    </div>
    <div id="input-line">
        <span id="help-btn">[help]</span>
        <span id="prompt">user@localhost:~$</span>
        <input type="text" id="command-input" autofocus>
    </div>

    <!-- Firebase JS SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>

    <script>
        // Firebase config
        const firebaseConfig = {
          apiKey: "AIzaSyDBBm7_VBqW0smF-7ecP1vaeTnMY68lc_w",
          authDomain: "my-terminal-chat-ecd4e.firebaseapp.com",
          projectId: "my-terminal-chat-ecd4e",
          storageBucket: "my-terminal-chat-ecd4e.firebasestorage.app",
          messagingSenderId: "401735371021",
          appId: "1:401735371021:web:81b1cf519130febee78844",
          measurementId: "G-SJ6VNQDS9M"
        }; 
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('command-input');
        const prompt = document.getElementById('prompt');
        const helpBtn = document.getElementById('help-btn');
        const exitBtn = document.getElementById('exit-btn');
        const clearBtn = document.getElementById('clear-btn');
        const obchatBtn = document.getElementById('obchat-btn');
        const notifBtn = document.getElementById('notif-btn');
        
        // Language support
        let currentLang = 'en';
        const translations = {
            en: {
                helpHint: "Type 'help' for available commands",
                help: `Available commands:
- help: Show this help message
- clear: Clear the terminal
- date: Show current date and time
- nick [name]: Set your nickname (only once) - registers you
- obchat: Enter general chat (type /exit to leave)
- tongue [lang]: Change language (en, ru)
- notif: Show notifications
- users_ip: Show users list with nick, id, status`,
                adminHelp: `\nAdmin commands (nk.exe2089 only):
- ban [nick|id] [time] [reason]: Ban a user from entering chat
- unban [nick|id] [reason]: Unban a user from chat
- bot [on|off]: Toggle moderation bot in chat
- prov: Check bot status
- usersip: Show registered users list with nick, ip, id, reg time, status
- nickeditor [id] [new_nick]: Change user's nick by ID
- clear_chat (in chat): Clear all chat messages`,
                dateCmd: () => new Date().toString(),
                nickSet: (nick) => `Nickname set to ${nick}. You are now registered!`,
                nickAlreadySet: 'Nickname can only be set once.',
                nickExists: 'Such nickname already exists.',
                nickUsage: 'Usage: nick <name>',
                setNickFirst: 'Please set a nickname first using "nick <name>".',
                obchatLeave: 'Left general chat.',
                chatFull: 'Chat is full. Maximum 50 users.',
                unknownChatCmd: (cmd) => `Unknown chat command: /${cmd}`,
                unknownLang: (lang) => `Unknown language: ${lang}. Available: en, ru`,
                tongueUsage: 'Usage: tongue <lang> (en, ru)',
                onlyAdmin: 'This command is only available to the admin.',
                banUsage: 'Usage: ban <nick|id> <time> [reason]\nTime format: 30s, 50m, 78h, 79d (or 30с, 50м, 78ч, 79д)',
                banSet: (target, end, reason) => `User ${target} has been banned until ${end} for: ${reason}`,
                youBanned: (end, reason) => `You are banned from entering chat until ${end} for: ${reason}`,
                targetNotFound: (target) => `Target ${target} not found.`,
                unbanUsage: 'Usage: unban <nick|id] [reason]',
                unbanDone: (target, reason) => `User ${target} has been unbanned. Reason: ${reason}`,
                notBanned: (target) => `User ${target} is not banned.`,
                usersIpTitle: 'Registered Users List\nOnline users: ',
                usersIpFormat: '\nNick\tIP\tID\tReg Time\tStatus\n',
                noUsers: 'No registered users yet.\n',
                botOn: 'Moderation bot enabled in chat.',
                botOff: 'Moderation bot disabled in chat.',
                botStatusOn: 'Bot is ON.',
                botStatusOff: 'Bot is OFF.',
                botInvalid: 'Usage: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} banned for 5 minutes for insults to relatives.`,
                notifTitle: 'Notifications:\n',
                notifEmpty: 'No notifications.',
                nickeditorUsage: 'Usage: nickeditor <id> <new_nick>',
                idNotFound: 'ID not found.',
                nickTaken: 'New nick is already taken.',
                nickChanged: (id, old, neww) => `Nick for ${id} changed from ${old} to ${neww}.`,
                clearChat: 'Chat cleared by admin.',
                chatDate: (date, count, max) => `${date} (${count}/${max} online)`,
                exitReminder: 'Type /exit to leave the chat.',
                youInChat: 'You are in general chat.',
                remainingMessages: 'General chat remaining messages',
                onlineStatus: 'Online',
                offlineStatus: 'Offline',
                usersIpUsersTitle: 'Users List\n',
                usersIpUsersFormat: '\nNick\tID\tStatus\n'
            },
            ru: {
                helpHint: "Введите 'help' для списка команд",
                help: `Доступные команды:
- help: Показать это сообщение помощи
- clear: Очистить терминал
- date: Показать текущую дату и время
- nick [имя]: Установить ваш никнейм (только один раз) - регистрирует вас
- obchat: Войти в общий чат (введите /exit для выхода)
- tongue [lang]: Сменить язык (en, ru)
- notif: Показать уведомления
- users_ip: Показать список пользователей с ником, ид, статусом`,
                adminHelp: `\nКоманды администратора (только для nk.exe2089):
- ban [ник|ид] [время] [причина]: Забанить пользователя от входа в чат
- unban [ник|ид] [причина]: Разбанить пользователя из чата
- bot [on|off]: Включить/выключить модерационного бота в чате
- prov: Проверить статус бота
- usersip: Показать список зарегистрированных пользователей с ником, айпи, ид, временем регистрации, статусом
- nickeditor [ид] [новый_ник]: Изменить ник пользователя по ID
- clear_chat (в чате): Очистить все сообщения чата`,
                dateCmd: () => new Date().toLocaleString('ru-RU'),
                nickSet: (nick) => `Никнейм установлен: ${nick}. Вы теперь зарегистрированы!`,
                nickAlreadySet: 'Никнейм можно установить только один раз.',
                nickExists: 'Такой никнейм уже существует.',
                nickUsage: 'Использование: nick <имя>',
                setNickFirst: 'Сначала установите никнейм с помощью "nick <имя>".',
                obchatLeave: 'Вышли из общего чата.',
                chatFull: 'Чат заполнен. Максимум 50 пользователей.',
                unknownChatCmd: (cmd) => `Неизвестная команда чата: /${cmd}`,
                unknownLang: (lang) => `Неизвестный язык: ${lang}. Доступны: en, ru`,
                tongueUsage: 'Использование: tongue <lang> (en, ru)',
                onlyAdmin: 'Эта команда доступна только администратору.',
                banUsage: 'Использование: ban <ник|ид] <время] [причина]\nФормат времени: 30s, 50m, 78h, 79d (или 30с, 50м, 78ч, 79д)',
                banSet: (target, end, reason) => `Пользователь ${target} забанен до ${end} за: ${reason}`,
                youBanned: (end, reason) => `Вы забанены от входа в чат до ${end} за: ${reason}`,
                targetNotFound: (target) => `Цель ${target} не найдена.`,
                unbanUsage: 'Использование: unban <ник|ид] [причина разбана]',
                unbanDone: (target, reason) => `Пользователь ${target} разбанен. Причина: ${reason}`,
                notBanned: (target) => `Пользователь ${target} не забанен.`,
                usersIpTitle: 'Список зарегистрированных пользователей\nОнлайн пользователей: ',
                usersIpFormat: '\nНик\tАйпи\tID\tВремя регистрации\tСтатус\n',
                noUsers: 'Нет зарегистрированных пользователей.\n',
                botOn: 'Модерационный бот включен в чате.',
                botOff: 'Модерационный бот выключен в чате.',
                botStatusOn: 'Бот включен.',
                botStatusOff: 'Бот выключен.',
                botInvalid: 'Использование: bot on|off',
                botBanMsg: (nick) => `BOT: ${nick} забанен на 5 минут за оскорбления родных.`,
                notifTitle: 'Уведомления:\n',
                notifEmpty: 'Нет уведомлений.',
                nickeditorUsage: 'Использование: nickeditor <ид] <новый_ник>',
                idNotFound: 'ID не найден.',
                nickTaken: 'Новый ник уже занят.',
                nickChanged: (id, old, neww) => `Ник для ${id} изменен с ${old} на ${neww}.`,
                clearChat: 'Чат очищен администратором.',
                chatDate: (date, count, max) => `${date} (${count}/${max} онлайн)`,
                exitReminder: 'Введите /exit для выхода из чата.',
                youInChat: 'Вы в общем чате.',
                remainingMessages: 'В общем чате остались сообщения',
                onlineStatus: 'Онлайн',
                offlineStatus: 'Оффлайн',
                usersIpUsersTitle: 'Список пользователей\n',
                usersIpUsersFormat: '\nНик\tID\tСтатус\n'
            }
        };
        
        function updateLanguage() {
            const t = translations[currentLang];
            const helpHintEl = document.getElementById('help-hint');
            if (helpHintEl) helpHintEl.textContent = t.helpHint;
        }
        
        // Chat simulation
        let currentNick = 'user';
        let userId = null;
        let isNickSet = false;
        let inChat = false;
        let bannedUsers = new Map();
        let botEnabled = false;
        let notifications = [];
        let registeredUsers = new Map(); // lowerNick -> {displayNick, id, ip, regTime, lastLogin}
        let chatListener = null;
        let onlineUsers = new Set();
        let onlineRef = null;
        let onlineListener = null;
        let chatDateShown = false;
        const MAX_CHAT_USERS = 50;
        const MAX_DISPLAY_MESSAGES = 10;
        const LOAD_MESSAGES_COUNT = 30;
        
        // Firebase paths
        const USERS_PATH = 'users';
        const IDS_PATH = 'ids';
        const BANS_PATH = 'bans';
        const CHAT_MESSAGES_PATH = 'chat_messages';
        const BOT_SETTINGS_PATH = 'bot_settings';
        const ONLINE_USERS_PATH = 'online_users';
        
        // Generate unique ID
        async function generateUniqueID() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            while (true) {
                let id = '';
                for (let i = 0; i < 4; i++) {
                    id += chars[Math.floor(Math.random() * chars.length)];
                }
                const snap = await db.ref(`${IDS_PATH}/${id}`).once('value');
                if (!snap.exists()) {
                    return id;
                }
            }
        }
        
        // Load state from Firebase
        async function loadState() {
            try {
                // Load user data using the persisted nick
                const lowerNick = currentNick.toLowerCase();
                const userSnapshot = await db.ref(`${USERS_PATH}/${lowerNick}`).once('value');
                const userData = userSnapshot.val();
                if (userData) {
                    currentNick = userData.display_nick || currentNick;
                    userId = userData.id;
                    currentLang = userData.lang || 'en';
                    isNickSet = userData.is_nick_set || false;
                    notifications = userData.notifications || [];
                    notifications = notifications.slice(-50);
                }
                if (isNickSet && !userId) {
                    userId = await generateUniqueID();
                    await db.ref(`${USERS_PATH}/${lowerNick}/id`).set(userId);
                    await db.ref(`${IDS_PATH}/${userId}`).set(lowerNick);
                }

                // Load bot enabled
                const botSnapshot = await db.ref(BOT_SETTINGS_PATH).once('value');
                const botData = botSnapshot.val();
                botEnabled = botData?.enabled || false;

                // Load bans
                await loadBans();

                // Load registered users
                const regsSnapshot = await db.ref(USERS_PATH).once('value');
                if (regsSnapshot.exists()) {
                    regsSnapshot.forEach((childSnapshot) => {
                        const user = childSnapshot.val();
                        const key = childSnapshot.key;
                        registeredUsers.set(key, {
                            displayNick: user.display_nick,
                            id: user.id,
                            ip: user.ip,
                            regTime: new Date(user.reg_time).getTime(),
                            lastLogin: user.last_login ? new Date(user.last_login).getTime() : null
                        });
                    });
                }

                updateLanguage();
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        // Save user state
        async function saveUserState() {
            try {
                const lowerNick = currentNick.toLowerCase();
                await db.ref(`${USERS_PATH}/${lowerNick}`).update({
                    display_nick: currentNick,
                    id: userId,
                    lang: currentLang,
                    is_nick_set: isNickSet,
                    notifications: notifications,
                    ip: generateIP(),
                    last_login: new Date().toISOString()
                });
                if (userId) {
                    await db.ref(`${IDS_PATH}/${userId}`).set(lowerNick);
                }
            } catch (error) {
                console.error('Error saving user state:', error);
            }
        }

        // Update last login on online set
        async function setOnline() {
            const lowerNick = currentNick.toLowerCase();
            await db.ref(`${ONLINE_USERS_PATH}/${lowerNick}`).set(firebase.database.ServerValue.TIMESTAMP);
            await saveUserState(); // Updates last_login
            if (registeredUsers.has(lowerNick)) {
                registeredUsers.get(lowerNick).lastLogin = Date.now();
            }
        }

        async function setOffline() {
            const lowerNick = currentNick.toLowerCase();
            await db.ref(`${ONLINE_USERS_PATH}/${lowerNick}`).remove();
        }

        // Load bans
        async function loadBans() {
            try {
                const bansSnapshot = await db.ref(BANS_PATH).once('value');
                bannedUsers.clear();
                const toRemove = [];
                if (bansSnapshot.exists()) {
                    bansSnapshot.forEach((childSnapshot) => {
                        const ban = childSnapshot.val();
                        const endTime = new Date(ban.end_time).getTime();
                        if (Date.now() < endTime) {
                            bannedUsers.set(childSnapshot.key, {
                                endTime,
                                reason: ban.reason
                            });
                        } else {
                            toRemove.push(childSnapshot.key);
                        }
                    });
                }
                if (toRemove.length > 0) {
                    await Promise.all(toRemove.map(key => db.ref(`${BANS_PATH}/${key}`).remove()));
                }
            } catch (error) {
                console.error('Error loading bans:', error);
            }
        }

        // Save bans
        async function saveBans() {
            try {
                const updates = {};
                bannedUsers.forEach((ban, nick) => {
                    updates[`${BANS_PATH}/${nick}`] = {
                        end_time: new Date(ban.endTime).toISOString(),
                        reason: ban.reason
                    };
                });
                await db.ref().update(updates);
            } catch (error) {
                console.error('Error saving bans:', error);
            }
        }

        // Save bot state
        async function saveBotState(enabled) {
            try {
                await db.ref(BOT_SETTINGS_PATH).set({ enabled });
                botEnabled = enabled;
            } catch (error) {
                console.error('Error saving bot state:', error);
            }
        }

        function addNotification(msg) {
            const timestamp = new Date().toLocaleString(getLocale());
            const notif = `${timestamp}: ${msg}`;
            notifications.push(notif);
            notifications = notifications.slice(-50);
            saveUserState();
        }

        async function registerUser(nick) {
            await saveUserState(); // Registers via set
        }

        async function saveBan(lowerNick, banData) {
            bannedUsers.set(lowerNick, banData);
            await db.ref(`${BANS_PATH}/${lowerNick}`).set({
                end_time: new Date(banData.endTime).toISOString(),
                reason: banData.reason
            });
        }

        async function deleteBan(lowerNick) {
            bannedUsers.delete(lowerNick);
            await db.ref(`${BANS_PATH}/${lowerNick}`).remove();
        }

        // Load chat messages realtime
        function loadChatMessages() {
            if (chatListener) {
                db.ref(CHAT_MESSAGES_PATH).off('child_added', chatListener);
            }
            const chatRef = db.ref(CHAT_MESSAGES_PATH).limitToLast(LOAD_MESSAGES_COUNT);
            let messageCount = 0;
            chatListener = (snapshot) => {
                if (messageCount >= MAX_DISPLAY_MESSAGES) return;
                const msg = snapshot.val();
                const msgTime = new Date(msg.timestamp).toLocaleTimeString(getLocale(), {hour: '2-digit', minute: '2-digit'});
                const msgElement = document.createElement('div');
                msgElement.className = 'chat-message output';
                msgElement.textContent = `${msg.nick}[${msg.id}]: [${msgTime}] ${msg.text}`;
                terminal.appendChild(msgElement);
                messageCount++;
                terminal.scrollTop = terminal.scrollHeight;
            };
            chatRef.on('child_added', chatListener);
        }

        function unloadChatMessages() {
            if (chatListener) {
                db.ref(CHAT_MESSAGES_PATH).off('child_added', chatListener);
                chatListener = null;
            }
        }

        // Listen for online users
        function setupOnlineListener() {
            onlineRef = db.ref(ONLINE_USERS_PATH);
            onlineListener = (snapshot) => {
                const data = snapshot.val() || {};
                onlineUsers.clear();
                Object.entries(data).forEach(([key, val]) => {
                    const lastSeen = val;
                    if (Date.now() - lastSeen < 30000) {
                        onlineUsers.add(key);
                    }
                });
                if (inChat) {
                    updatePrompt();
                    // Update chat date with current count
                    updateChatDate();
                }
            };
            onlineRef.on('value', onlineListener);
        }

        function getTranslations() {
            return translations[currentLang];
        }
        
        function getLocale() {
            switch (currentLang) {
                case 'en': return 'en-US';
                case 'ru': return 'ru-RU';
                default: return 'en-US';
            }
        }
        
        function generateIP() {
            return `192.168.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
        }
        
        function parseDuration(str) {
            const match = str.match(/^(\d+)([smhdсмчд])$/i);
            if (!match) return null;
            const num = parseInt(match[1]);
            let unit = match[2].toLowerCase();
            switch (unit) {
                case 's':
                case 'с': return num * 1000;
                case 'm':
                case 'м': return num * 60 * 1000;
                case 'h':
                case 'ч': return num * 60 * 60 * 1000;
                case 'd':
                case 'д': return num * 24 * 60 * 60 * 1000;
                default: return null;
            }
        }
        
        function isAdmin() {
            return currentNick === '🜲الشيطان🜲';
        }
        
        function handleBotModeration(message, senderNick) {
            // Test mode - no action for now
            console.log('Bot test: message checked');
        }
        
        async function checkBanAndExitIfNeeded() {
            const lowerNick = currentNick.toLowerCase();
            if (bannedUsers.has(lowerNick)) {
                const ban = bannedUsers.get(lowerNick);
                if (Date.now() < ban.endTime) {
                    inChat = false;
                    updatePrompt();
                    unloadChatMessages();
                    await setOffline();
                    const t = getTranslations();
                    const locale = getLocale();
                    const endStr = new Date(ban.endTime).toLocaleString(locale);
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = t.youBanned(endStr, ban.reason);
                    terminal.appendChild(outputElement);
                    saveTerminal();
                    terminal.scrollTop = terminal.scrollHeight;
                    return true; // Kicked
                } else {
                    await deleteBan(lowerNick);
                }
            }
            return false; // Not kicked
        }
        
        // Function to execute help command
        async function executeHelp() {
            if (inChat) {
                // If in chat, just output help as message or exit first? For simplicity, output in terminal
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} help`;
                terminal.appendChild(inputElement);
                
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = helpText;
                terminal.appendChild(outputElement);
            } else {
                // Normal mode
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} help`;
                terminal.appendChild(inputElement);
                
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = helpText;
                terminal.appendChild(outputElement);
            }
            saveTerminal();
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        // Local commands
        function updatePrompt() {
            const t = getTranslations();
            if (inChat) {
                prompt.textContent = `${currentNick}[${userId}]@obchat (${onlineUsers.size}/${MAX_CHAT_USERS}): `;
            } else {
                prompt.textContent = `${currentNick}@localhost:~$`;
            }
        }

        // Show/update chat date header
        async function showChatDate() {
            const t = getTranslations();
            // Clear entire terminal
            terminal.innerHTML = '';
            // Add divider
            const divider1 = document.createElement('div');
            divider1.className = 'divider';
            divider1.textContent = '//--//--//--//--//--//--//';
            terminal.appendChild(divider1);
            // Add you in chat
            const status = document.createElement('div');
            status.className = 'chat-status';
            status.textContent = t.youInChat;
            terminal.appendChild(status);
            // Add second divider
            const divider2 = document.createElement('div');
            divider2.className = 'divider';
            divider2.textContent = '//--//--//--//--//--//--//';
            terminal.appendChild(divider2);
            // Add date
            const today = new Date().toLocaleDateString(getLocale(), { 
                day: 'numeric', 
                month: 'long'
            });
            const dateElement = document.createElement('div');
            dateElement.className = 'chat-date';
            dateElement.textContent = t.chatDate(today, onlineUsers.size, MAX_CHAT_USERS);
            terminal.appendChild(dateElement);
            // Check if there are messages
            const countSnap = await db.ref(CHAT_MESSAGES_PATH).once('value');
            const messageCount = countSnap.numChildren();
            if (messageCount > 0) {
                // Add remaining messages
                const remaining = document.createElement('div');
                remaining.className = 'remaining-messages';
                remaining.textContent = t.remainingMessages;
                terminal.appendChild(remaining);
            }
            chatDateShown = true;
            terminal.scrollTop = terminal.scrollHeight;
        }

        function updateChatDate() {
            const dateElement = terminal.querySelector('.chat-date');
            if (dateElement) {
                const t = getTranslations();
                const today = new Date().toLocaleDateString(getLocale(), { 
                    day: 'numeric', 
                    month: 'long'
                });
                dateElement.textContent = t.chatDate(today, onlineUsers.size, MAX_CHAT_USERS);
            }
        }
        
        const localCommands = {
            'help': () => {
                const t = getTranslations();
                let helpText = t.help;
                if (isAdmin()) {
                    helpText += t.adminHelp;
                }
                return helpText;
            },
            'clear': (args) => {
                // Clear outputs but keep pinned
                const pinned = terminal.querySelectorAll('.pinned');
                terminal.innerHTML = '';
                pinned.forEach(p => terminal.appendChild(p));
                inChat = false;
                chatDateShown = false;
                updatePrompt();
                updateLanguage();
                saveTerminal();
                return '';
            },
            'date': () => {
                const t = getTranslations();
                return t.dateCmd();
            },
            'nick': async (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    if (isNickSet) {
                        return t.nickAlreadySet;
                    }
                    const newNick = args.join(' ');
                    const newLowerNick = newNick.toLowerCase();
                    // Check if nick already exists
                    const existingSnapshot = await db.ref(`${USERS_PATH}/${newLowerNick}`).once('value');
                    if (existingSnapshot.exists()) {
                        return t.nickExists;
                    }
                    const id = await generateUniqueID();
                    const oldNick = currentNick;
                    currentNick = newNick;
                    userId = id;
                    localStorage.setItem('currentNick', currentNick); // Persist nick in localStorage
                    isNickSet = true;
                    // Set full user data for new user
                    await db.ref(`${USERS_PATH}/${newLowerNick}`).set({
                        display_nick: newNick,
                        id: id,
                        lang: currentLang,
                        is_nick_set: true,
                        notifications: [],
                        ip: generateIP(),
                        reg_time: new Date().toISOString()
                    });
                    await db.ref(`${IDS_PATH}/${id}`).set(newLowerNick);
                    updatePrompt();
                    // If was admin, check if new is admin too
                    if (oldNick === 'nk.exe2089' && currentNick !== 'nk.exe2089') {
                        return `Nickname changed from ${oldNick} to ${currentNick}. Admin privileges lost.`;
                    }
                    await saveUserState();
                    return t.nickSet(currentNick);
                } else {
                    return t.nickUsage;
                }
            },
            'obchat': async () => {
                await loadBans(); // Ensure bans are loaded
                const t = getTranslations();
                if (!isNickSet) {
                    return t.setNickFirst;
                }
                if (!userId) {
                    return t.setNickFirst;
                }
                if (onlineUsers.size >= MAX_CHAT_USERS) {
                    return t.chatFull;
                }
                const lowerNick = currentNick.toLowerCase();
                if (bannedUsers.has(lowerNick)) {
                    const ban = bannedUsers.get(lowerNick);
                    if (Date.now() < ban.endTime) {
                        const locale = getLocale();
                        const endStr = new Date(ban.endTime).toLocaleString(locale);
                        return t.youBanned(endStr, ban.reason);
                    } else {
                        await deleteBan(lowerNick);
                    }
                }
                // Clear entire terminal
                terminal.innerHTML = '';
                inChat = true;
                updatePrompt();
                await showChatDate();
                loadChatMessages();
                await setOnline();
                // No return message
                return '';
            },
            'tongue': async (args) => {
                const t = getTranslations();
                if (args.length > 0) {
                    const lang = args[0].toLowerCase();
                    if (['en', 'ru'].includes(lang)) {
                        currentLang = lang;
                        await saveUserState();
                        updateLanguage();
                        updatePrompt();
                        return `Language changed to ${lang}`;
                    } else {
                        return t.unknownLang(lang);
                    }
                } else {
                    return t.tongueUsage;
                }
            },
            'notif': () => {
                const t = getTranslations();
                if (notifications.length === 0) {
                    return t.notifEmpty;
                }
                let output = t.notifTitle;
                notifications.forEach(n => {
                    output += `${n}\n`;
                });
                return output;
            },
            'users_ip': () => {
                const t = getTranslations();
                let output = t.usersIpUsersTitle + onlineUsers.size + '\n' + t.usersIpUsersFormat;
                const sortedRegs = Array.from(registeredUsers.entries()).sort((a, b) => (b[1].lastLogin || 0) - (a[1].lastLogin || 0));
                sortedRegs.forEach(([lowerNick, data]) => {
                    const nick = data.displayNick;
                    const id = data.id;
                    const status = onlineUsers.has(lowerNick) ? t.onlineStatus : t.offlineStatus;
                    output += `${nick}\t${id}\t${status}\n`;
                });
                if (sortedRegs.length === 0) {
                    output += t.noUsers;
                }
                return output;
            },
            'ban': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 2) {
                    return t.banUsage;
                }
                const targetStr = args[0];
                let targetLower;
                if (/^[a-z0-9]{4}$/i.test(targetStr)) {
                    const idSnap = await db.ref(`${IDS_PATH}/${targetStr.toLowerCase()}`).once('value');
                    if (!idSnap.exists()) {
                        return t.targetNotFound(targetStr);
                    }
                    targetLower = idSnap.val();
                } else {
                    targetLower = targetStr.toLowerCase();
                }
                const timeStr = args[1];
                const reason = args.slice(2).join(' ') || 'No reason provided';
                const duration = parseDuration(timeStr);
                if (!duration) {
                    return t.banUsage;
                }
                const endTime = Date.now() + duration;
                const locale = getLocale();
                const endStr = new Date(endTime).toLocaleString(locale);
                const banData = { endTime, reason };
                await saveBan(targetLower, banData);
                const banMsg = t.banSet(targetStr, endStr, reason);
                addNotification(banMsg);
                // Check if self-banned and in chat
                if (targetLower === currentNick.toLowerCase() && inChat) {
                    checkBanAndExitIfNeeded();
                }
                return banMsg;
            },
            'unban': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 1) {
                    return t.unbanUsage;
                }
                const targetStr = args[0];
                let targetLower;
                if (/^[a-z0-9]{4}$/i.test(targetStr)) {
                    const idSnap = await db.ref(`${IDS_PATH}/${targetStr.toLowerCase()}`).once('value');
                    if (!idSnap.exists()) {
                        return t.targetNotFound(targetStr);
                    }
                    targetLower = idSnap.val();
                } else {
                    targetLower = targetStr.toLowerCase();
                }
                if (!bannedUsers.has(targetLower)) {
                    return t.notBanned(targetStr);
                }
                await deleteBan(targetLower);
                const reason = args.slice(1).join(' ') || 'No reason provided';
                const unbanMsg = t.unbanDone(targetStr, reason);
                addNotification(unbanMsg);
                return unbanMsg;
            },
            'nickeditor': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 2) {
                    return t.nickeditorUsage;
                }
                const id = args[0].toLowerCase();
                if (!/^[a-z0-9]{4}$/.test(id)) {
                    return t.idNotFound;
                }
                const newNick = args.slice(1).join(' ');
                if (!newNick) {
                    return t.nickeditorUsage;
                }
                const newLower = newNick.toLowerCase();
                // Get oldLower
                const idRef = db.ref(`${IDS_PATH}/${id}`);
                const idSnap = await idRef.once('value');
                if (!idSnap.exists()) {
                    return t.idNotFound;
                }
                const oldLower = idSnap.val();
                const userRef = db.ref(`${USERS_PATH}/${oldLower}`);
                const userSnap = await userRef.once('value');
                if (!userSnap.exists()) {
                    return 'User data not found.';
                }
                const userData = userSnap.val();
                const oldDisplay = userData.display_nick;
                // Check new nick not taken
                const newUserSnap = await db.ref(`${USERS_PATH}/${newLower}`).once('value');
                if (newUserSnap.exists()) {
                    return t.nickTaken;
                }
                // Proceed
                await db.ref(`${USERS_PATH}/${oldLower}`).remove();
                await db.ref(`${USERS_PATH}/${newLower}`).set({
                    ...userData,
                    display_nick: newNick
                });
                // Update ids/{id} = newLower
                await idRef.set(newLower);
                // If online, move online entry
                const oldOnlineRef = db.ref(`${ONLINE_USERS_PATH}/${oldLower}`);
                const newOnlineRef = db.ref(`${ONLINE_USERS_PATH}/${newLower}`);
                const oldOnlineSnap = await oldOnlineRef.once('value');
                if (oldOnlineSnap.exists()) {
                    const timestamp = oldOnlineSnap.val();
                    await oldOnlineRef.remove();
                    await newOnlineRef.set(timestamp);
                }
                // If it's current user
                if (oldLower === currentNick.toLowerCase()) {
                    currentNick = newNick;
                    localStorage.setItem('currentNick', newNick);
                    updatePrompt();
                }
                // Update registeredUsers cache
                registeredUsers.delete(oldLower);
                registeredUsers.set(newLower, {
                    displayNick: newNick,
                    id: userData.id,
                    ip: userData.ip,
                    regTime: new Date(userData.reg_time).getTime(),
                    lastLogin: userData.last_login ? new Date(userData.last_login).getTime() : null
                });
                return t.nickChanged(id, oldDisplay, newNick);
            },
            'bot': async (args) => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                if (args.length < 1) {
                    return t.botInvalid;
                }
                const action = args[0].toLowerCase();
                if (action === 'on') {
                    await saveBotState(true);
                    return t.botOn;
                } else if (action === 'off') {
                    await saveBotState(false);
                    return t.botOff;
                } else {
                    return t.botInvalid;
                }
            },
            'prov': () => {
                const t = getTranslations();
                if (!isAdmin()) {
                    return t.onlyAdmin;
                }
                return botEnabled ? t.botStatusOn : t.botStatusOff;
            },
            'usersip': () => {
                const t = getTranslations();
                let output = t.usersIpTitle + onlineUsers.size + t.usersIpFormat;
                const sortedRegs = Array.from(registeredUsers.entries()).sort((a, b) => b[1].regTime - a[1].regTime);
                sortedRegs.forEach(([lowerNick, data]) => {
                    const nick = data.displayNick;
                    const ip = data.ip;
                    const id = data.id;
                    const regStr = new Date(data.regTime).toLocaleString(getLocale());
                    const status = onlineUsers.has(lowerNick) ? t.onlineStatus : t.offlineStatus;
                    output += `${nick}\t${ip}\t${id}\t${regStr}\t${status}\n`;
                });
                if (sortedRegs.length === 0) {
                    output += t.noUsers;
                }
                return output;
            }
        };
        
        // Button event listeners
        exitBtn.addEventListener('click', async () => {
            if (inChat) {
                const t = getTranslations();
                inChat = false;
                updatePrompt();
                unloadChatMessages();
                await setOffline();
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = t.obchatLeave;
                terminal.appendChild(outputElement);
                saveTerminal();
                terminal.scrollTop = terminal.scrollHeight;
            }
        });

        clearBtn.addEventListener('click', () => {
            const args = [];
            localCommands['clear'](args);
        });

        obchatBtn.addEventListener('click', async () => {
            const args = [];
            const output = await localCommands['obchat']();
            if (output !== '') {
                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = output;
                terminal.appendChild(outputElement);
                saveTerminal();
                terminal.scrollTop = terminal.scrollHeight;
            }
        });

        notifBtn.addEventListener('click', () => {
            const output = localCommands['notif']();
            if (output !== '') {
                const inputElement = document.createElement('div');
                inputElement.className = 'command';
                inputElement.textContent = `${prompt.textContent} notif`;
                terminal.appendChild(inputElement);

                const outputElement = document.createElement('div');
                outputElement.className = 'output';
                outputElement.textContent = output;
                terminal.appendChild(outputElement);
                saveTerminal();
                terminal.scrollTop = terminal.scrollHeight;
            }
        });
        
        commandInput.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                const inputValue = commandInput.value.trim();
                if (inputValue === '') {
                    commandInput.value = '';
                    return;
                }
                const commandText = inputValue;
                commandInput.value = '';
                
                let output = '';
                
                if (inChat) {
                    // Check ban before processing message
                    if (await checkBanAndExitIfNeeded()) {
                        return; // Kicked, don't process
                    }
                    
                    if (commandText.startsWith('/')) {
                        // Echo chat commands as regular command
                        const inputElement = document.createElement('div');
                        inputElement.className = 'command';
                        inputElement.textContent = `${prompt.textContent} ${commandText}`;
                        terminal.appendChild(inputElement);
                        
                        const [chatCmd, ...args] = commandText.slice(1).split(' ');
                        if (chatCmd === 'exit') {
                            const t = getTranslations();
                            inChat = false;
                            updatePrompt();
                            unloadChatMessages();
                            await setOffline();
                            output = t.obchatLeave;
                        } else if (chatCmd === 'nick') {
                            // Support /nick in chat, but check if set
                            const t = getTranslations();
                            if (args.length > 0) {
                                if (isNickSet) {
                                    output = t.nickAlreadySet;
                                } else {
                                    const newNick = args.join(' ');
                                    const newLowerNick = newNick.toLowerCase();
                                    // Check if nick already exists
                                    const existingSnapshot = await db.ref(`${USERS_PATH}/${newLowerNick}`).once('value');
                                    if (existingSnapshot.exists()) {
                                        output = t.nickExists;
                                    } else {
                                        const id = await generateUniqueID();
                                        const oldNick = currentNick;
                                        currentNick = newNick;
                                        userId = id;
                                        localStorage.setItem('currentNick', currentNick); // Persist in localStorage
                                        isNickSet = true;
                                        // Set full user data for new user
                                        await db.ref(`${USERS_PATH}/${newLowerNick}`).set({
                                            display_nick: newNick,
                                            id: id,
                                            lang: currentLang,
                                            is_nick_set: true,
                                            notifications: [],
                                            ip: generateIP(),
                                            reg_time: new Date().toISOString()
                                        });
                                        await db.ref(`${IDS_PATH}/${id}`).set(newLowerNick);
                                        updatePrompt();
                                        if (oldNick === 'nk.exe2089' && currentNick !== 'nk.exe2089') {
                                            output = `Nickname changed from ${oldNick} to ${currentNick}. Admin privileges lost.`;
                                        } else {
                                            output = t.nickSet(currentNick);
                                        }
                                        await saveUserState();
                                    }
                                }
                            } else {
                                output = t.nickUsage;
                            }
                        } else if (chatCmd === 'clear_chat') {
                            const t = getTranslations();
                            if (!isAdmin()) {
                                output = t.onlyAdmin;
                            } else {
                                try {
                                    await db.ref(CHAT_MESSAGES_PATH).remove();
                                    output = t.clearChat;
                                } catch (error) {
                                    console.error('Error clearing chat:', error);
                                    output = 'Error clearing chat.';
                                }
                            }
                        } else {
                            const t = getTranslations();
                            output = t.unknownChatCmd(chatCmd);
                        }
                    } else {
                        // General chat message - send to Firebase
                        await db.ref(CHAT_MESSAGES_PATH).push({
                            nick: currentNick,
                            id: userId,
                            text: commandText,
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        });
                        
                        // Bot moderation
                        handleBotModeration(commandText, currentNick);
                        
                        // Check ban after moderation
                        await checkBanAndExitIfNeeded();
                        
                        terminal.scrollTop = terminal.scrollHeight;
                        return; // No further processing
                    }
                } else {
                    // Normal command mode
                    const inputElement = document.createElement('div');
                    inputElement.className = 'command';
                    inputElement.textContent = `${prompt.textContent} ${commandText}`;
                    terminal.appendChild(inputElement);
                    
                    const [command, ...args] = commandText.split(' ');
                    if (localCommands[command]) {
                        output = await localCommands[command](args);
                    } else {
                        output = `Unknown command: ${command}`;
                    }
                }
                
                if (output !== '') {
                    const outputElement = document.createElement('div');
                    outputElement.className = 'output';
                    outputElement.textContent = output;
                    terminal.appendChild(outputElement);
                }
                
                saveTerminal();
                // Scroll to bottom
                terminal.scrollTop = terminal.scrollHeight;
            }
        });
        
        // Help button click
        helpBtn.addEventListener('click', async () => {
            await executeHelp();
        });
        
        // Focus the input on click anywhere
        document.body.addEventListener('click', () => {
            commandInput.focus();
        });
        
        // Terminal save fallback to localStorage
        function saveTerminal() {
            localStorage.setItem('pipelTerminal', terminal.innerHTML);
        }
        
        // Initial setup
        async function init() {
            // Load persisted nick from localStorage
            const savedNick = localStorage.getItem('currentNick');
            if (savedNick) {
                currentNick = savedNick;
                // Assume set if saved
                isNickSet = true;
            }
            await loadState();
            setupOnlineListener();
            const savedTerminal = localStorage.getItem('pipelTerminal');
            if (savedTerminal) {
                terminal.innerHTML = savedTerminal;
            } else {
                // No initial pinned help hint
                saveTerminal();
            }
            updateLanguage();
            updatePrompt();
            commandInput.focus(); // Ensure focus on mobile
        }
        init();
    </script>
</body>
    </html>
